<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ruleskit.activation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ruleskit.activation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
from typing import Union, List, Optional
import numpy as np
import ast
import sys
from copy import copy
import random
import psutil
from math import ceil
from time import time
from bitarray import bitarray
from tempfile import gettempdir
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

try:
    from transparentpath import TransparentPath
except ImportError:
    TransparentPath = None

MAX_INT_32 = 2 ** 32


# noinspection PyAttributeOutsideInit
class Activation(ABC):

    &#34;&#34;&#34;An activation vector is a 1-D list of 0 and 1 reprenseting the activation of a rule. Each element corresponds to
    a line in the features and targets data (typically, a date, or a pair date-object if the data is multi-indexed),
    and the vector contains 0 if the condition of the rule is not met at this index in the data and 1 if it is.

    When working with lots of data and lots of rules, activation vectors can be hard to keep in memory and can represent
    bottlenecks in computation time. This class is designed to reduce the size in memory of the vector and to minimize
    the computation time.
    &#34;&#34;&#34;

    # dtype for the compressed format. Can be str or np.ndarray
    DTYPE = str
    # When calling a profiling attribute that is None, will force the call of the method to compute them if FORCE_STAT
    # is True
    FORCE_STAT = False
    # Should be set to True if the program will do ogical AND between activation vectors in integer format at some point
    WILL_COMPARE = False
    # If activation vectors are to be stored on disk instead of RAM, root directory to store them
    DEFAULT_TEMPDIR = Path(gettempdir())
    # If no formatting should be done, just store raw np.ndarray in RAM
    STORE_RAW = False
    # Number of processes that will be using Activation class. Used when doing memory-intensive operations.
    NCPUS = 1

    &#34;&#34;&#34; Class methods &#34;&#34;&#34;

    @classmethod
    def clean_files(cls):
        &#34;&#34;&#34;Removes activation vector files, if any.&#34;&#34;&#34;
        if not cls.DEFAULT_TEMPDIR.is_dir():
            return
        for path in cls.DEFAULT_TEMPDIR.glob(&#34;ACTIVATION_VECTOR_*.txt&#34;):
            path.unlink()

    &#34;&#34;&#34;Init methods&#34;&#34;&#34;

    def _reset_data_related_attributes(self):

        # Analytical attributes
        self._entropy = None  # Will be set if activation is not an integer or if optimize is True
        self._rel_entropy = None  # Will be set if activation is not an integer or if optimize is True
        self._nones = None  # Will be set if activation is not an integer or if optimize is True
        self._coverage = None

        # Format attributes
        self.length = None  # Will be set by init methods
        self.data = None  # Will be set by init methods

        &#34;&#34;&#34;
        Profiling attribtues. All times are in seconds, all sizes in MB. Attributes starting by &#39;_n_&#39; are counts of
        how many times this or that method triggered.
        &#34;&#34;&#34;

        self._time_write = -1
        self._time_read = -1
        self._time_compressed_to_raw = -1
        self._time_raw_to_compressed = -1
        self._time_raw_to_integer = -1
        self._time_bitarray_to_raw = -1
        self._time_raw_to_bitarray = -1
        self._time_compressed_to_bitarray = -1
        self._time_compressed_to_integer = -1
        self._time_bitarray_to_compressed = -1
        self._time_integer_to_compressed = -1
        self._time_integer_to_raw = -1
        self._time_bitarray_to_integer = -1
        self._time_integer_to_bitarray = -1
        self._n_written = 0
        self._n_read = 0
        self._n_compressed_to_raw = 0
        self._n_raw_to_compressed = 0
        self._n_bitarray_to_raw = 0
        self._n_integer_to_raw = 0
        self._n_raw_to_bitarray = 0
        self._n_raw_to_integer = 0
        self._n_bitarray_to_compressed = 0
        self._n_integer_to_compressed = 0
        self._n_compressed_to_bitarray = 0
        self._n_compressed_to_integer = 0
        self._n_bitarray_to_integer = 0
        self._n_integer_to_bitarray = 0
        self._sizeof_compressed_array = -1
        self._sizeof_compressed_str = -1
        self._sizeof_bitarray = -1
        self._sizeof_integer = -1
        self._sizeof_raw = -1
        self._sizeof_file = -1
        self._sizeof_path = -1

    def __init__(
        self,
        activation: Union[np.ndarray, bitarray, str, int, Path],
        optimize: bool = True,
        length: Optional[int] = None,
        to_file: bool = True,
    ):
        &#34;&#34;&#34;
        An activation vector is an array of 0 and 1, possibly millions of points. The whole purpose of this class is
        to efficiently store the vector and allow to use logcial AND easily between two vectors, no matter the stored
        format.

        The possible storing format are : compressed string or array, integer, bitarray or written on disk.
        Activations are written on disk only if &#39;to_file&#39; is True and Activation.STORE_RAW is False (default).
        In that case, the raw np.ndarray vector is stored using np.save.
        If the vector is instantiated with any of compressed string or array, integer, bitarray, then this format is
        privileged for storing the vector (unless to_file is True or Activation.STORE_RAW is True), but some other flags
        like &#39;optimize&#39; and &#39;Activation.WILL_COMPARE&#39; can determine the chosen format.

        If the raw np.ndarray or a path to it was given and if Activation.STORE_RAW is True, then no formatting is done
        and the raw np.ndarray is kept in RAM. This flag has no effect if activation is not the raw np.ndarray nor a
        path to it.

        Compression : can be either compressed str(list) or np.ndarray, depending on Activation.DTYPE:
            Compressed data is : First element of the list is the first value of the array, last element of the list is
            the length of the array. The other elements are the coordinates where the array changed values. This is the
            best solution regarding the RAM if the vector does not change often. However, it is often slower than the
            other methods, particularly if the code will apply logical AND between vectors since it requieres a
            decompression of both vectors.
            The vector is stored that was if compression is more memory-efficient than integer or bitarray format
            OR if optimize is False, or if &#39;activation&#39; is already a compressed vector.
            It is never stored this way if to_file is True or Activation.STORE_RAW is True.
        Bitarray :
            The input vector [1 0 0 1 0 0 0 1 1...] where each entry uses up one bit of memory. Takes more RAM than
            compressed format if the vector does not change often, but is much quicker, both in conversion and in
            computing a logical AND.
            The vector is stored that way if it takes less RAM than compressed and if optimize is True and if
            Activation.WILL_COMPARE is False (converting to bitarray is faster than to integer, but computing
            logical AND on integers is faster). Size is equivalent to integer : one bit per entry. It is also stored
            this way if &#39;activation&#39; is a string and Activation.WILL_COMPARE is False.
            It is never stored this way if to_file is True or Activation.STORE_RAW is True.
        Integer :
            taking the input vector [1 0 0 1 0 0 0 1 1...], converts it to binary string representation :
            &#34;100100011...&#34; then casts it into int using int(s, 2).
            The vector is stored that way if it takes less RAM than compressed and if optimize is True and if
            Activation.WILL_COMPARE is True. It is also stored this way if &#39;activation&#39; is a string and
            Activation.WILL_COMPARE is True. It is never stored this way if to_file is True or Activation.STORE_RAW is
            True.
        File stored locally :
            This is done if to_file is True and Activation.STORE_RAW is False (default). It is often the best solution,
            and is the default one. Indeed the I/O operations using np.save and np.load are very fast, and the only
            thing in RAM is the path to the vector&#39;s file. One need enough disk space of course. Using this method will
            save the np.array with dtype=np.ubyte, so taking one byte (8 bits) per entry.

        If compression is used and dtype is np.ndarray, will check that numbers present in the compressed vector can be
        stored as int32 to gain memory. Else, uses int64.

        Parameters:
        -----------
        activation: Union[np.ndarray, bitarray, str, int, Path]
            If np.ndarray : Of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], or compressed vector
            If str : compressed vector, or &#39;010011100011111&#39;, or path
            If bitarray : same as np.array but takes 8x less memory (each entry is stored in one bit only)
            If int : as an integer
            If Path : read raw np.ndarray vector from path.
        optimize: bool
            Only relevent if &#39;value&#39; is a bitarray or an integer. In that case, will check whether using compression
            saves up memory. Else, does not check and uses bitarray or integer. Note that if optimize is True, entropy
            is computed no matter the chosen format.
        length: Optional[int]
            Only valid if &#39;value&#39; is an integer. An activation vector stored as an integer has lost the information
            about its size : [0 0 0 1 0 0 0 1 1...] to int gives 100011... which in turn gives back [1 0 0 0 1 1...].
            To get the leading zeros back, one must specify the length of the activation vector.
        to_file: bool
            If True, then activation vector is stored in a file in
            Activation.DEFAULT_TEMPDIR / ACTIVATION_VECTOR_available_number.txt if Activation.STORE_RAW
            if False (default) (default value = True)
        &#34;&#34;&#34;

        self._reset_data_related_attributes()
        self.optimize = optimize
        self.to_file = False  # set by _init_with_any
        self.data_format = None  # Will be set by init methods

        # does not use instance to avoid conflicts if using TransparentPath
        if type(activation) == &#34;str&#34; and &#34;,&#34; not in activation:
            if any([c in activation for c in &#34;abcdefhijklmnopqrstuvwxy./\\&#34;]):  # is a file path
                if TransparentPath is not None:
                    # noinspection PyCallingNonCallable
                    activation = TransparentPath(activation)
                else:
                    activation = Path(activation)
            else:
                if Activation.WILL_COMPARE:
                    activation = int(activation, 2)
                else:
                    activation = bitarray(activation)
        elif isinstance(activation, int) and not Activation.WILL_COMPARE:
            if length is None:
                raise ValueError(&#34;When giving an integer to Activation, you must also specify its length.&#34;)
            self._sizeof_integer = sys.getsizeof(activation) / 1e6
            t0 = time()
            s = bin(activation)[2:]
            if len(s) != length:
                s = &#34;0&#34; * (length - len(s)) + s
            activation = bitarray(s)
            self._time_integer_to_bitarray = time() - t0
            self._n_integer_to_bitarray += 1
            self._sizeof_bitarray = sys.getsizeof(activation) / 1e6
        elif isinstance(activation, bitarray) and Activation.WILL_COMPARE:
            self._sizeof_bitarray = sys.getsizeof(activation) / 1e6
            self._nones = activation.count(1)
            t0 = time()
            if length is None:
                length = len(activation)
            activation = int(
                str(activation).replace(&#34;bitarray(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#39;&#34;&#39;, &#34;&#34;), 2
            )
            self._time_bitarray_to_integer = time() - t0
            self._n_bitarray_to_integer += 1
            self._sizeof_integer = sys.getsizeof(activation) / 1e6

        # noinspection PyTypeChecker
        if isinstance(activation, Path) or TransparentPath is not None and isinstance(activation, TransparentPath):
            activation = self._read(activation, out=False)

        self._init_with_any(activation, length, to_file)

    def _init_with_any(self, activation: Union[np.ndarray, bitarray, int, str], length: int, to_file: bool):
        if isinstance(activation, bitarray):
            self._init_with_bitarray(activation, Activation.DTYPE)

        elif isinstance(activation, int):
            self._init_with_integer(activation, Activation.DTYPE, length)

        elif isinstance(activation, str):
            self._init_with_str(activation)

        elif isinstance(activation, np.ndarray):
            if len(activation) &gt; 0 and activation[-1] &gt; 1:
                self._init_with_compressed_array(activation)
            else:
                if to_file and not self.__class__.STORE_RAW:
                    if not self._write(self.to_raw_from_any(activation, out=False)):
                        self._init_with_any(activation, length=length, to_file=False)
                    else:
                        self.to_file = True
                else:
                    self._init_with_raw(activation, Activation.DTYPE)
        else:
            raise TypeError(
                f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
                f&#34; {type(activation)}.&#34;
            )

    def _write(self, value: np.ndarray):
        &#34;&#34;&#34;Writes the activation vector&#39;s raw np.ndarray to a file in Activation.DEFAULT_TEMPDIR under the name
        ACTIVATION_VECTOR_{n}.txt, where n is a random integer chosen among available numbers from 0 to 1e64.

        Will set:
             * self._sizeof_raw
             * self.length
             * self._nones
             * self._sizeof_file
             * self._sizeof_path
             * self_time_write.
             * self.data to the path to the file
             * self.data_format as &#34;file&#34;
        Will iterate self._n_written.
        &#34;&#34;&#34;
        if value.dtype != np.ubyte:  # Saves memory
            value = value.astype(np.ubyte)
        logger.debug(f&#34;Activation vector is raw, store it in a file&#34;)
        self._sizeof_raw = value.nbytes / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)
        t0 = time()
        arange = list((0, int(1e64)))
        number = random.randint(*arange)
        data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        attempts = 0
        while data.is_file():
            if attempts &gt; 99:
                logger.warning(
                    &#34;Failed to save activation vector locally after 100 attempts at finding an available&#34;
                    &#34; name. Will keep it in RAM.&#34;
                )
                return False
            number += 1
            attempts += 1
            arange.remove(number)
            number = random.randint(*arange)
            data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        data.touch()
        self.data = data
        self.data_format = &#34;file&#34;
        with open(self.data, &#34;wb&#34;) as f:
            # noinspection PyTypeChecker
            np.save(f, value, allow_pickle=False)
        stat = self.data.stat()
        if isinstance(stat, dict):
            self._sizeof_file = stat[&#34;st_size&#34;] / 1e6
        else:
            self._sizeof_file = stat.st_size / 1e6
        self._sizeof_path = sys.getsizeof(self.data) / 1e6
        self._time_write = time() - t0
        self._n_written += 1
        return True

    def _init_with_bitarray(self, value: bitarray, dtype: type):

        &#34;&#34;&#34;
        Will set
            * self._nones (number of ones in the activation)
            * self.length
            * self._sizeof_bitarray
            if self.optimize is True:
                  * self._entropy and self._rel_entropy
                  * self.data_format to &#34;bitarray&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes
                    less memory
                  * self.data as a bitarray, a str or an array
                  Will iterate self._n_bitarray_to_compressed
            else:
                  * self.data as a bitarray
                  * self.data_format to &#34;bitarray&#34;
        &#34;&#34;&#34;

        logger.debug(f&#34;Activation vector is a bitarray&#34;)
        self.length = len(value)
        self._sizeof_bitarray = sys.getsizeof(value) / 1e6
        self._nones = value.count(1)

        if self.optimize:
            t0 = time()
            raw = self._bitarray_to_raw(value, out=False)
            t1 = time()
            compressed = self._compress(raw, dtype=dtype)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = compressed.nbytes / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed))
            else:
                self._entropy = len(compressed)
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_bitarray:
                self.data = value
                self.data_format = &#34;bitarray&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;bitarray&#34;

    def _init_with_integer(self, value: int, dtype: type, length: Optional[int] = None):

        &#34;&#34;&#34;
        Will set
            * self.length
            * self._sizeof_integer
            if self.optimize is True:
                * self._nones (number of ones in the activation)
                * self._entropy and self._rel_entropy
                * self.data_format to &#34;integer&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes less
                memory
                * self.data as an integer, a str or an np.ndarray
                Will iterate self._n_integer_to_compressed
            else:
                * self.data as an integer
                * self.data_format to &#34;integer&#34;
        &#34;&#34;&#34;

        if length is None:
            raise ValueError(&#34;When giving an integer to Activation, you must also specify its length.&#34;)

        logger.debug(f&#34;Activation vector is an int&#34;)
        self.length = length
        self._sizeof_integer = sys.getsizeof(value) / 1e6

        if self.optimize:
            t0 = time()
            raw = self._integer_to_raw(value, out=False)
            self._nones = np.count_nonzero(raw == 1)
            t1 = time()
            compressed = self._compress(raw, dtype=dtype)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = compressed.nbytes / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed))
            else:
                self._entropy = len(compressed)
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_integer:
                self.data = value
                self.data_format = &#34;integer&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;integer&#34;

    def _init_with_str(self, value: str):
        &#34;&#34;&#34;
        will set :
            * self.data as a compressed str
            * self._sizeof_compressed_str
            * self.data_format as &#34;compressed_str&#34;
            * self._entropy and self._rel_entropy
            * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed str&#34;)
        evaluated = np.array(ast.literal_eval(value))
        self.data = value
        self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        self._entropy = len(evaluated)
        self.length = evaluated[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_str&#34;

    def _init_with_compressed_array(self, value: np.ndarray):
        &#34;&#34;&#34;
        will set :
            * self.data as a compressed array
            * self._sizeof_compressed_array
            * self.data_format as &#34;compressed_array&#34;
            * self._entropy and self._rel_entropy
            * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed array&#34;)
        self.data = value
        self._sizeof_compressed_array = value.nbytes / 1e6
        self._entropy = len(value)
        self.length = value[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_array&#34;

    def _init_with_raw(self, value: np.ndarray, dtype: type):
        &#34;&#34;&#34;
        will set :
            * self.data as an integer or a compressed array/str depending on what takes less memory and on what dtype is
            * self._sizeof_compressed_str or self._sizeof_compressed_array if Activation.STORE_RAW is False
            * self._sizeof_raw
            * self._time_raw_to_compressed if Activation.STORE_RAW is False
            * self._time_raw_to_bitarray or integer if Activation.STORE_RAW is False
            * self._sizeof_bitarray or integer if Activation.STORE_RAW is False
            * self.data_format as &#34;bitarray&#34;, &#34;integer&#34;, &#34;raw&#34; or &#34;compressed_array&#34; or &#34;compressed_str&#34;
            * self._entropy and self._rel_entropy
            * self.length
            * self._nones
        Will iterate :
            * self._n_raw_to_bitarray or integer if Activation.STORE_RAW is False
            * self._n_raw_to_compressed if Activation.STORE_RAW is False
        &#34;&#34;&#34;
        if value.dtype != np.ubyte:
            value = value.astype(np.ubyte)
        logger.debug(f&#34;Activation vector is raw&#34;)
        self._sizeof_raw = value.nbytes / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)

        if Activation.STORE_RAW:
            self.data = value
            self.data_format = &#34;raw&#34;
            return

        t0 = time()
        compressed = self._compress(value, dtype=dtype)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if isinstance(compressed, str):
            self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            size_compressed = self._sizeof_compressed_str
        else:
            self._sizeof_compressed_array = compressed.nbytes / 1e6
            size_compressed = self._sizeof_compressed_array
        if dtype is str:
            self._entropy = len(ast.literal_eval(compressed))
        else:
            self._entropy = len(compressed)
        self._rel_entropy = self._entropy / self.length
        t0 = time()
        if Activation.WILL_COMPARE:
            inbit = self._raw_to_integer(value)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            self._sizeof_integer = sys.getsizeof(inbit) / 1e6
            thesize = self._sizeof_integer
            s = f&#34;Using integer activation representation&#34;
            fmt = &#34;integer&#34;
        else:
            inbit = self._raw_to_bitarray(value)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            self._sizeof_bitarray = sys.getsizeof(inbit) / 1e6
            thesize = self._sizeof_bitarray
            s = f&#34;Using bitarray activation representation&#34;
            fmt = &#34;bitarray&#34;
        if thesize &gt; size_compressed:
            logger.debug(f&#34;Using compressed activation representation&#34;)
            self.data = compressed
            if dtype == str:
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
        else:
            logger.debug(s)
            self.data_format = fmt
            self.data = inbit

    &#34;&#34;&#34; Binary operators &#34;&#34;&#34;

    def __and__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;logical AND of two activation vectors. Only valid if both have the same length. Both vectors DO NOT need
        to have the same format.&#34;&#34;&#34;
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):  # gains time by not using raw
            return Activation(self.data &amp; a2.data, optimize=self.optimize and a2.optimize, to_file=False)
        else:
            return Activation(
                self.raw * a2.raw,
                optimize=self.optimize and a2.optimize,
                to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;,
            )

    @staticmethod
    def multi_logical_and(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
        &#34;&#34;&#34;Do LOGICAL AND on many activation vectors at once. Uses raw np.ndarrays to gain time.
        If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;

        available_memory = psutil.virtual_memory().available / 1e6
        single_act_size = acs[0].sizeof_raw
        expected_size = single_act_size * len(acs) * Activation.NCPUS * 1.1  # factor 1.1 is just for safety
        if available_memory == 0:
            raise ValueError(&#34;No memory left to compute &#39;multi_logical_and&#39;&#34;)
        nbatches = ceil(expected_size / available_memory)
        if nbatches == 0:
            raise ValueError(
                f&#34;Not enough memory left to compute &#39;multi_logical_and&#39; : need {expected_size}MB,&#34;
                f&#34; has {available_memory}MB&#34;
            )
        batches = np.array_split(acs, nbatches)

        if len(acs) == 1:
            res = acs[0].raw
        else:
            if 2 * single_act_size &gt; available_memory:
                raise MemoryError(&#34;Will not be able to fit two activation vectors of size&#34;
                                  f&#34; {acs[0].sizeof_raw} in memory&#34;)
            res = []
            for batch in batches:
                res = np.vstack([a.raw for a in batch]).all(axis=0).astype(np.ubyte)
            res = np.vstack([a for a in res]).all(axis=0).astype(np.ubyte)
        if asarray:
            return res
        return Activation(
            res,
            optimize=all([a.optimize for a in acs]),
            to_file=all([a.data_format == &#34;file&#34; for a in acs]),
        )

    def __or__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;LOGICAL OR of two activation vectors. Only valid if both have the same length. Both vectors DO NOT need
        to have the same format.&#34;&#34;&#34;
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):  # gains time by not using raw
            return Activation(self.data | a2.data, optimize=self.optimize and a2.optimize, to_file=False)
        else:
            return Activation(
                self.raw | a2.raw,
                optimize=self.optimize and a2.optimize,
                to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;,
            )

    @staticmethod
    def multi_logical_or(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
        &#34;&#34;&#34;Do LOGICAL OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
        If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;

        available_memory = psutil.virtual_memory().available / 1e6
        single_act_size = acs[0].sizeof_raw
        expected_size = single_act_size * len(acs) * Activation.NCPUS * 1.1  # factor 1.1 is just for safety
        if available_memory == 0:
            raise MemoryError(&#34;No memory left to compute &#39;multi_logical_or&#39;&#34;)
        nbatches = ceil(expected_size / available_memory)
        if nbatches == 0:
            raise MemoryError(
                f&#34;Not enough memory left to compute &#39;multi_logical_or&#39; : need {expected_size}MB,&#34;
                f&#34; has {available_memory}MB&#34;
            )
        batches = np.array_split(acs, nbatches)

        if len(acs) == 1:
            res = acs[0].raw
        else:
            if 2 * single_act_size &gt; available_memory:
                raise MemoryError(&#34;Will not be able to fit two activation vectors of size&#34;
                                  f&#34; {acs[0].sizeof_raw} in memory&#34;)
            res = []
            for batch in batches:
                res.append(np.vstack([a.raw for a in batch]).any(axis=0).astype(np.ubyte))
            res = np.vstack([a for a in res]).any(axis=0).astype(np.ubyte)
        if asarray:
            return res
        return Activation(
            res,
            optimize=all([a.optimize for a in acs]),
            to_file=all([a.data_format == &#34;file&#34; for a in acs]),
        )

    def __xor__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;Logcial EXCLUSIVE OR of two activation vectors. Only valid if both have the same length. Both vectors DO NOT
        need to have the same format.&#34;&#34;&#34;
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):  # gains time by not using raw
            return Activation(self.data ^ a2.data, optimize=self.optimize and a2.optimize, to_file=False)
        else:
            return Activation(
                self.raw ^ a2.raw,
                optimize=self.optimize and a2.optimize,
                to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;,
            )

    @staticmethod
    def multi_logical_xor(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
        &#34;&#34;&#34;Do LOGICAL EXCLUSIVE OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
        If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;
        if len(acs) == 1:
            return Activation(acs[0].raw, optimize=acs[0].optimize, to_file=acs[0].data_format == &#34;file&#34;)
        lor = Activation.multi_logical_or(acs, True)
        nland = -(Activation.multi_logical_and(acs, True) - 1)
        res = lor &amp; nland.astype(np.ubyte)
        if asarray:
            return res
        return Activation(
            res,
            optimize=all([a.optimize for a in acs]),
            to_file=all([a.data_format == &#34;file&#34; for a in acs]),
        )

    def __add__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;Synonym of logical OR&#34;&#34;&#34;
        return self or other

    def __sub__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;Logical EXCLUSIVE OR then logical AND&#34;&#34;&#34;
        return (self ^ other) &amp; self

    &#34;&#34;&#34; Other methods &#34;&#34;&#34;

    def __copy__(self) -&gt; &#34;Activation&#34;:
        if self.data_format == &#34;integer&#34;:
            return Activation(copy(self.data), optimize=self.optimize, length=self.length)
        return Activation(copy(self.data), optimize=self.optimize, to_file=self.data_format == &#34;file&#34;)

    def clear(self):
        &#34;&#34;&#34;Fill Activation with zeros&#34;&#34;&#34;
        data = np.zeros(self.length)
        self._reset_data_related_attributes()
        self._init_with_raw(data, Activation.DTYPE)

    def delete(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, either by deleting the local file or by calling del on self.data. In
        the later case, self.data is reset to None.&#34;&#34;&#34;
        if self.data_format == &#34;file&#34;:
            if self.data.is_file():
                self.data.unlink()
        else:
            del self.data
            self.data = None

    def __len__(self):
        &#34;&#34;&#34;Number of points in the vector&#34;&#34;&#34;
        return self.length

    def __contains__(self, other: &#34;Activation&#34;) -&gt; bool:
        intersection = self &amp; other
        nones_intersection = intersection.nones
        intersection.delete()
        if nones_intersection &lt; min(self.nones, other.nones):
            return False
        return True

    def get_correlation(self, other: &#34;Activation&#34;) -&gt; float:
        &#34;&#34;&#34; Computes the correlation between self and other
        Correlation is the number of points in common between the two vectors divided by their length.
        Both vectors must have the same length.
        &#34;&#34;&#34;
        if not len(self) == len(other):
            raise ValueError(&#34;Both vectors must have the same length&#34;)

        common_points = np.count_nonzero(self.raw == other.raw)
        return common_points / len(self)

    &#34;&#34;&#34; Conversions to raw methods&#34;&#34;&#34;

    def to_raw_from_any(self, activation, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;Converts any format among integer, bitarray, compressed string or compressed array to raw activation
        vector np.ndarray&#34;&#34;&#34;
        if isinstance(activation, bitarray):
            raw = self._bitarray_to_raw(activation, out=out)
        elif isinstance(activation, int):
            raw = self._integer_to_raw(activation, out=out)
        elif isinstance(activation, (str, np.ndarray)):
            raw = self._decompress(activation, raw=True, out=out)
        else:
            raise TypeError(
                f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
                f&#34; {type(activation)}.&#34;
            )
        return raw

    def _read(self, path: Optional[TransparentPath] = None, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;Read a raw activation vector&#39;s np.ndarray, either from given path, or from self.data. In that case, will
        raise ValueError if self.data_format is not &#34;file&#34;.

        If out is not True or value is None, will set:
            * self._sizeof_raw
            * self._nones
            * self._time_read
            * self._sizeof_file
            * self._sizeof_path
            Will iterate self._n_read
        &#34;&#34;&#34;
        if path is None:
            out = False
            if not self.data_format == &#34;file&#34;:
                raise ValueError(&#34;Activation vector was not saved locally : can not read it.&#34;)
            path = self.data
        t0 = time()
        with open(path, &#34;rb&#34;) as f:
            # noinspection PyTypeChecker
            value = np.load(f)
        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = value.nbytes / 1e6
            if self._nones is None:
                self._nones = np.count_nonzero(value == 1)
            stat = path.stat()
            if isinstance(stat, dict):
                self._sizeof_file = stat[&#34;st_size&#34;] / 1e6
            else:
                self._sizeof_file = stat.st_size / 1e6
            self._sizeof_path = sys.getsizeof(self.data) / 1e6
            self._time_read = time() - t0
            self._n_read += 1
        return value

    def _integer_to_raw(self, value: Optional[int] = None, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;From a value of the form 45786542 (int), which is the base 10 representation of the binary form of an
        activation vector, returns the raw np.ndarray vector of the form [1, 0, 0, 1, 1, 0, ...].

        If out is not True or value is None, will set:
            * self._sizeof_integer
            * self._sizeof_raw
            * self._time_integer_to_raw
            * self._nones
            Will iterate :
                * self._n_integer_to_raw
        &#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (len(value) == 0 or value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_integer_to_raw = time() - t0
                self._n_integer_to_raw += 1
            return value

        if isinstance(value, (bitarray, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _integer_to_raw on a bitarray, raw, compressed or a path&#34;)
        if not isinstance(value, int):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.fromiter(bin(value)[2:], dtype=np.ubyte)
        if not out:
            self._sizeof_integer = sys.getsizeof(value) / 1e6

        if len(act) &gt; self.length:
            raise ValueError(
                &#34;After using _integer_to_raw, I ended up with an activation vector bigger than the specified &#34;
                &#34;max length. This should not happend as the max length should have been set by the indexing &#34;
                &#34;of x earlier in your code&#34;
            )
        act_bis = np.zeros(self.length).astype(np.ubyte)
        act_bis[self.length - len(act):] = act

        if not out:
            self._sizeof_raw = act_bis.nbytes / 1e6
            self._time_integer_to_raw = time() - t0
            self._n_integer_to_raw += 1
            if self._nones is None:
                self._nones = np.count_nonzero(act_bis == 1)
        return act_bis

    def _bitarray_to_raw(self, value: Union[bitarray, Path] = None, out=True) -&gt; np.ndarray:
        &#34;&#34;&#34;Transforms a bitarray to a np.ndarray

        If out is not True or value is None, will set:
            * self._sizeof_bitarray
            * self._sizeof_raw
            * self._time_bitarray_to_raw
            * self._nones
            Will iterate :
                * self._n_bitarray_to_raw
        &#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (len(value) == 0 or value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_bitarray_to_raw = time() - t0
                self._n_bitarray_to_raw += 1
            return value

        if isinstance(value, (int, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _bitarray_to_raw on a raw, integer, compressed or a path&#34;)
        if not isinstance(value, bitarray):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.array(list(value), dtype=np.ubyte)

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = act.nbytes / 1e6
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(value) / 1e6
            self._time_bitarray_to_raw = time() - t0
            self._n_bitarray_to_raw += 1
        return act

    def _decompress(
        self, value: Union[str, np.ndarray, Path] = None, raw=True, out=True
    ) -&gt; Union[np.ndarray, bitarray, int]:
        &#34;&#34;&#34;From a compressed array of either str or np.ndarray format, will return the raw np.ndarray vector of the form
        [0, 1, 1, 1, 0, 0, 1, ...]

        If raw is True (default), returns it as a np.ndarray, else as a bitarray

        If out is False or value is None, will set:
            * self._time_compressed_to_raw
            * self._sizeof_compressed_str or _sizeof_compressed_array
            * self._sizeof_raw
            * self._nones
            Will iterate :
                * self._n_compressed_to_raw
        raw if False and Activation.WILL_COMPARE is True/False:
            * self._time_compressed_to_integer/bitarray
            * self._sizeof_nteger/bitarray
            Will iterate :
                * self._n_compressed_to_nteger/bitarray
        &#34;&#34;&#34;
        t0 = time()

        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, (int, bitarray, Path)):
            raise TypeError(&#34;Can not apply _decompress on a bitarray, integer or Path&#34;)
        if not isinstance(value, (str, np.ndarray)):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)

        if len(value) == 0:
            if isinstance(value, np.ndarray):  # is already raw
                if not out:
                    self._sizeof_raw = value.nbytes / 1e6
                    if self._nones is None:
                        self._nones = np.count_nonzero(value == 1)
                return value
            else:
                if not out:
                    self._sizeof_raw = np.array([]).nbytes / 1e6
                    self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
                    if self._nones is None:
                        self._nones = 0
                return np.array([])
        if value[-1] == 0 or value[-1] == 1:  # is already raw
            if not out:
                self._sizeof_raw = value.nbytes / 1e6
                if self._nones is None:
                    self._nones = np.count_nonzero(value == 1)
            return value

        if isinstance(value, str):
            act = ast.literal_eval(value)
            if not out:
                self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        elif isinstance(value, np.ndarray):
            act = value
            if not out:
                self._sizeof_compressed_array = value.nbytes / 1e6
        else:
            raise TypeError(f&#34;&#39;value&#39; can not be of type {type(value)}&#34;)

        length = act[-1]
        s = np.zeros(length, dtype=np.ubyte)
        previous_value = 0
        previous_index = 0

        if act[0] == 1:
            previous_value = 1
            s[0] = 1
        if len(act) == 2:
            if act[0] == 1:
                s = np.ones(length, dtype=np.ubyte)
        else:
            for index in act[1:]:
                if previous_value == 0:
                    previous_index = index
                    previous_value = 1
                else:
                    s[previous_index:index] = np.ones(index - previous_index)
                    previous_index = index
                    previous_value = 0
        s = np.array(s, dtype=np.ubyte)

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = s.nbytes / 1e6
            self._time_compressed_to_raw = time() - t0
            self._n_compressed_to_raw += 1
            if self._nones is None:
                self._nones = np.count_nonzero(s == 1)

        if raw:
            act = s
            fmt = &#34;raw&#34;
        elif Activation.WILL_COMPARE:
            t1 = time()
            act = self._raw_to_integer(s)
            if not out:
                self._time_raw_to_integer = time() - t1
                self._n_raw_to_integer += 1
            fmt = &#34;integer&#34;
        else:
            t1 = time()
            # noinspection PyTypeChecker
            act = self._raw_to_bitarray(s)
            if not out:
                self._time_raw_to_bitarray = time() - t1
                self._n_raw_to_bitarray += 1
            fmt = &#34;bitarray&#34;

        if not out:
            if fmt == &#34;integer&#34;:
                # noinspection PyTypeChecker
                if self._sizeof_integer == -1:
                    self._sizeof_integer = sys.getsizeof(act) / 1e6
                self._time_compressed_to_integer = time() - t0
                self._n_compressed_to_integer += 1
            elif fmt == &#34;bitarray&#34;:
                # noinspection PyTypeChecker
                if self._sizeof_bitarray == -1:
                    self._sizeof_bitarray = sys.getsizeof(act) / 1e6
                self._time_compressed_to_bitarray = time() - t0
                self._n_compressed_to_bitarray += 1
        return act

    &#34;&#34;&#34; Conversions from raw methods&#34;&#34;&#34;

    @staticmethod
    def _compress(value: Union[np.ndarray, str], dtype: type = str) -&gt; Union[np.ndarray, str]:
        &#34;&#34;&#34;Transforms a raw or bitarray activation vector to a compressed one.

        A compressed vector is a collection of integers starting by the initial value of the raw vector (0 or 1) and
        ending with its length. The other integers in the compression are the positions in the raw vector where the
        vector value changes. This stores all the information and saves up memory if the vector is constant over
        large periods of time.

        The compressed vector can be stored as a str looking like &#34;0, 12, 456, ..., 47782&#34; or as a numpy array of
        integers. What storage to use is specified by the &#34;dtype&#34; argument.
        &#34;&#34;&#34;
        if isinstance(value, (int, bitarray)):
            raise TypeError(&#34;Can not compress an integer vector&#34;)
        if not isinstance(value, np.ndarray) or (len(value) &gt; 0 and value[-1] != 0 and value[-1] != 1):
            if isinstance(value, str) and dtype != str:
                return np.array(value.split(&#34;,&#34;)).astype(np.ubyte)
            return value
        if isinstance(value, np.ndarray):
            # not ubyte (unsigned byte), because np.diff will produce negative value that ubyte can not handle
            value = value.astype(np.byte)
            if len(value) == 0:
                return np.array([])
        else:
            raise TypeError(f&#34;Can not compress a {type(value)}&#34;)
        to_ret = [value[0]]
        diff_arr = abs(np.diff(value))
        to_ret += list(np.where(diff_arr == 1)[0] + 1)
        to_ret.append(len(value))
        if dtype == str:
            to_ret = str(to_ret).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
        else:
            if to_ret[-1] &lt; MAX_INT_32:
                to_ret = np.array(to_ret, dtype=&#34;int32&#34;)
            else:
                to_ret = np.array(to_ret, dtype=&#34;int64&#34;)
        return to_ret

    @staticmethod
    def _raw_to_bitarray(value: np.ndarray) -&gt; bitarray:
        &#34;&#34;&#34;Casts a raw activation vector into a bitarray, dividing its size in MO by 8.&#34;&#34;&#34;
        if isinstance(value, bitarray):
            return value
        elif not isinstance(value, np.ndarray) or (len(value) &gt; 0 and value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a compressed vector&#34;)
        elif isinstance(value, int):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a integer vector&#34;)
        # noinspection PyTypeChecker
        return bitarray(value.tolist())

    @staticmethod
    def _raw_to_integer(value: np.ndarray) -&gt; int:
        &#34;&#34;&#34;Casts a raw activation vector into the integer represented by its binary form, dividing its size in MO by 8.

        Examples
        --------
        &gt;&gt;&gt; from ruleskit import Activation
        &gt;&gt;&gt; Activation._raw_to_integer(np.array([0, 1, 1, 0]))
        6  # the binary number &#39;0110&#39; is 6 in base 10
        &#34;&#34;&#34;
        if isinstance(value, int):
            return value
        elif not isinstance(value, np.ndarray) or (len(value) &gt; 0 and value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_integer or a compressed vector&#34;)
        elif isinstance(value, bitarray):
            raise TypeError(&#34;Can not use _raw_to_integer on a bitarray vector&#34;)
        to_ret = int(&#34;&#34;.join(str(i) for i in value.astype(np.ubyte)), 2)
        return to_ret

    &#34;&#34;&#34;properties&#34;&#34;&#34;

    @property
    def ones(self) -&gt; np.ndarray:
        &#34;&#34;&#34;ones is the list of indexes where the vector is 1
        Contrary to other @properties, do not store &#39;ones&#39; in self, for it can be quit large : several MB or more.
        When running codes with millions of vector, this can be problematic.&#34;&#34;&#34;
        raw = self.raw
        ones = np.where(raw == 1)[0].tolist()
        return ones

    @property
    def nones(self) -&gt; int:
        &#34;&#34;&#34;nones is the number of points where the activation vector is 1
        self._nones might not be set since it can only be set at object creation if the full array was given or
        accessed at some point
        &#34;&#34;&#34;
        if self._nones is None:
            _ = self.raw  # calling raw will compute nones

        if self._coverage is None:
            self._coverage = self._nones / self.length
        return self._nones

    @property
    def entropy(self) -&gt; int:
        &#34;&#34;&#34;The entropy of the vector is the length of its compressed reprensentation : the number of times it switched
        from 1 to 0 and vice versa, plus 1 for the information about its initial value, and again 1 for the Information
        about its size.
        Like self._nones, it might not have been computed yet. In that case, compute it.

        If entropy is ocmputed here, will set:
            * self._time_bitarray_to_compressed or self._time_integer_to_compressed
            * self._sizeof_compressed_str or self._sizeof_compressed_array
            * self._entropy (you don&#39;t say)
            * self._rel_entropy
            Will iterate :
                * self._n_bitarray_to_compressed or self._n_integer_to_compressed
        &#34;&#34;&#34;
        if self._entropy is None:
            t0 = time()
            fmt = self.data_format
            if self.data_format == &#34;file&#34;:
                data = self._read(out=False)
                fmt = &#34;raw&#34;
            else:
                data = self.data

            if fmt == &#34;bitarray&#34;:
                data = self._bitarray_to_raw(data, out=False)
                compressed = self._compress(data)
                self._time_bitarray_to_compressed = time() - t0
                self._n_bitarray_to_compressed += 1
            elif fmt == &#34;integer&#34;:
                data = self._integer_to_raw(data, out=False)
                compressed = self._compress(data)
                self._time_integer_to_compressed = time() - t0
                self._n_integer_to_compressed += 1
            elif fmt == &#34;raw&#34;:
                compressed = self._compress(data)
                self._time_raw_to_compressed = time() - t0
                self._n_raw_to_compressed += 1
            else:
                raise ValueError(f&#34;Entropy should have been computed already if format is {fmt}&#34;)

            if self.data_format == &#34;compressed_str&#34;:
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            if self.data_format == &#34;compressed_array&#34;:
                self._sizeof_compressed_array = compressed.nbytes / 1e6

            self._entropy = len(ast.literal_eval(compressed))
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return self._entropy

    @property
    def rel_entropy(self) -&gt; float:
        &#34;&#34;&#34;Relative entropy is the entropy divided by the length of the raw np.ndarray vector
        Like self._nones, it might not have been computed yet. In that case, compute it.
        &#34;&#34;&#34;
        if self._rel_entropy is None:
            _ = self.entropy  # will set self._rel_entropy
        return self._rel_entropy

    @property
    def coverage(self) -&gt; float:
        &#34;&#34;&#34;Coverage is the fraction of points equal to 1 in the vector
        Like self._nones, it might not have been computed yet. In that case, compute it.
        &#34;&#34;&#34;
        if self._coverage is None:
            _ = self.nones  # will set self._coverage
        return self._coverage

    &#34;&#34;&#34;Method to access various formats&#34;&#34;&#34;

    @property
    def raw(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the raw np.ndarray. Will set relevant profiling attributes.&#34;&#34;&#34;
        if self.data_format == &#34;raw&#34;:
            return self.data
        elif self.data_format == &#34;bitarray&#34;:
            return self._bitarray_to_raw(out=False)
        elif self.data_format == &#34;integer&#34;:
            return self._integer_to_raw(out=False)
        elif self.data_format == &#34;file&#34;:
            return self._read(out=False)
        elif &#34;compressed&#34; in self.data_format:
            return self._decompress(out=False)
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_bitarray(self) -&gt; bitarray:
        &#34;&#34;&#34;Returns the bitarray representation of the vector&#34;&#34;&#34;
        if self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            t0 = time()
            to_ret = self._raw_to_bitarray(data)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._raw_to_bitarray(self.data)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            return self.data
        elif self.data_format == &#34;integer&#34;:
            t0 = time()
            s = bin(self.data)[2:]
            if len(s) != self.length:
                s = &#34;0&#34; * (self.length - len(s)) + s
            to_ret = bitarray(s)
            self._time_integer_to_bitarray = time() - t0
            self._n_integer_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif &#34;compressed&#34; in self.data_format:
            wc = Activation.WILL_COMPARE
            Activation.WILL_COMPARE = False
            to_ret = self._decompress(raw=False, out=False)
            Activation.WILL_COMPARE = wc
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the integer representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;

        if self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            t0 = time()
            to_ret = self._raw_to_integer(data)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._raw_to_integer(self.data)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;integer&#34;:
            return self.data
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = int(str(self.data).replace(&#34;bitarray(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#39;&#34;&#39;, &#34;&#34;), 2)
            self._time_bitarray_to_integer = time() - t0
            self._n_bitarray_to_integer += 1
            self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif &#34;compressed&#34; in self.data_format:
            wc = Activation.WILL_COMPARE
            Activation.WILL_COMPARE = True
            to_ret = self._decompress(raw=False, out=False)
            Activation.WILL_COMPARE = wc
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_compressed(self) -&gt; Union[str]:
        &#34;&#34;&#34;Returns the compressed str representation of the vector.
        Will set relevant profiling attributes.&#34;&#34;&#34;
        return self.as_compressed_str

    @property
    def as_compressed_array(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the compressed array representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;
        if self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;compressed_array&#34;:
            to_ret = self.data
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;compressed_str&#34;:
            to_ret = np.array(ast.literal_eval(self.data))
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;integer&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            t0 = time()
            to_ret = self._compress(data, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)
        self._entropy = len(to_ret)
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return to_ret

    @property
    def as_compressed_str(self) -&gt; str:
        &#34;&#34;&#34;Returns the compressed str representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;
        if self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=str)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;compressed_str&#34;:
            to_ret = self.data
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;compressed_array&#34;:
            to_ret = str(self.data.tolist()).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;integer&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=str)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=str)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;file&#34;:
            t0 = time()
            data = self._read(out=False)
            to_ret = self._compress(data, dtype=str)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)
        self._entropy = len(ast.literal_eval(to_ret))
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return to_ret

    @property
    def sizeof_path(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the path object, or -1 if it does not exist.
        In that case and if Activation.FORCE_STAT is True, will force the object to write the file to compute the
         relevant profiling attributes.&#34;&#34;&#34;
        if self._sizeof_path == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._sizeof_path

    @property
    def sizeof_file(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the path object, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._sizeof_file == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._sizeof_file

    @property
    def sizeof_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of raw np.ndarray vector, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.raw to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._sizeof_raw == -1 and Activation.FORCE_STAT:
            _ = self.raw
        return self._sizeof_raw

    @property
    def sizeof_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in bitarray, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_bitarray to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_bitarray == -1 and Activation.FORCE_STAT:
            _ = self.as_bitarray
        return self._sizeof_bitarray

    @property
    def sizeof_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in integer, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_integer to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_integer == -1 and Activation.FORCE_STAT:
            _ = self.as_integer
        return self._sizeof_integer

    @property
    def sizeof_compressed_array(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in compressed array, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_compressed_array to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_compressed_array == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_array
        return self._sizeof_compressed_array

    @property
    def sizeof_compressed_str(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in compressed str, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_compressed_str to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_compressed_str == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_str
        return self._sizeof_compressed_str

    @property
    def time_write(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to write the vector to a file, or -1 if it does not exist. In that case and
        if Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._time_write == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._time_write

    @property
    def time_read(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to read the vector to a file, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._time_read == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            _ = self._read(self.data, out=False)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._time_read

    @property
    def time_raw_to_compressed(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._compress to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._time_raw_to_compressed == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.raw
            self.data_format = &#34;raw&#34;
            _ = self.as_compressed
            self.data = data
            self.data_format = fmt
        return self._time_raw_to_compressed

    @property
    def time_raw_to_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds go from raw to integer, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._raw_to_integer to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_raw_to_integer == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.raw
            self.data_format = &#34;raw&#34;
            _ = self.as_integer
            self.data = data
            self.data_format = fmt
        return self._time_raw_to_integer

    @property
    def time_raw_to_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds go from raw to bitarray, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._raw_to_bitarray to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_raw_to_bitarray == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.raw
            self.data_format = &#34;raw&#34;
            _ = self.as_bitarray
            self.data = data
            self.data_format = fmt
        return self._time_raw_to_bitarray

    @property
    def time_compressed_to_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._decompress to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_compressed_to_raw == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_compressed
            if isinstance(self.data, str):
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
            _ = self.raw
            self.data = data
            self.data_format = fmt
        return self._time_compressed_to_raw

    @property
    def time_bitarray_to_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to raw, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._bitarray_to_raw to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_bitarray_to_raw == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_bitarray
            self.data_format = &#34;bitarray&#34;
            _ = self.raw
            self.data = data
            self.data_format = fmt
        return self._time_bitarray_to_raw

    @property
    def time_integer_to_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from integer to raw, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._integer_to_raw to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_integer_to_raw == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_integer
            self.data_format = &#34;integer&#34;
            _ = self.raw
            self.data = data
            self.data_format = fmt
        return self._time_integer_to_raw

    @property
    def time_compressed_to_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from compressed to bitarray, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._decompress on self.as_compressed with
         &#39;raw=False&#39; to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_compressed_to_bitarray == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_compressed
            if isinstance(self.data, str):
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
            _ = self.as_bitarray
            self.data = data
            self.data_format = fmt
        return self._time_compressed_to_bitarray

    @property
    def time_bitarray_to_compressed(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to compressed, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._compress on self.as_bitarray to
        compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_bitarray_to_compressed == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_bitarray
            self.data_format = &#34;bitarray&#34;
            _ = self.as_compressed
            self.data = data
            self.data_format = fmt
        return self._time_bitarray_to_compressed

    @property
    def time_integer_to_compressed(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from integer to compressed, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._compress on
        self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_integer_to_compressed == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_integer
            self.data_format = &#34;integer&#34;
            _ = self.as_compressed
            self.data = data
            self.data_format = fmt
        return self._time_integer_to_compressed

    @property
    def time_bitarray_to_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._compress on
        self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_bitarray_to_integer == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_bitarray
            self.data_format = &#34;bitarray&#34;
            _ = self.as_integer
            self.data = data
            self.data_format = fmt
        return self._time_bitarray_to_integer

    @property
    def time_integer_to_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self.as_integer on
        self to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_integer_to_bitarray == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_integer
            self.data_format = &#34;integer&#34;
            _ = self.as_bitarray
            self.data = data
            self.data_format = fmt
        return self._time_integer_to_bitarray

    @property
    def time_compressed_to_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from compressed to integer, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self.as_compress on
        to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_compressed_to_integer == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_compressed
            if isinstance(self.data, str):
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
            _ = self.as_integer
            self.data = data
            self.data_format = fmt
        return self._time_compressed_to_integer

    @property
    def n_written(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was written to disk.&#34;&#34;&#34;
        return self._n_written

    @property
    def n_read(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was read from disk.&#34;&#34;&#34;
        return self._n_read

    @property
    def n_raw_to_compressed(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was compressed from raw.&#34;&#34;&#34;
        return self._n_raw_to_compressed

    @property
    def n_compressed_to_raw(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to raw.&#34;&#34;&#34;
        return self._n_compressed_to_raw

    @property
    def n_raw_to_bitarray(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was formatted as bitarray.&#34;&#34;&#34;
        return self._n_raw_to_bitarray

    @property
    def n_raw_to_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was formatted as integer.&#34;&#34;&#34;
        return self._n_raw_to_integer

    @property
    def n_bitarray_to_raw(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was deformatted from bitarray.&#34;&#34;&#34;
        return self._n_bitarray_to_raw

    @property
    def n_integer_to_raw(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was deformatted from integer.&#34;&#34;&#34;
        return self._n_integer_to_raw

    @property
    def n_bitarray_to_compressed(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was compressed from bitarray.&#34;&#34;&#34;
        return self._n_bitarray_to_compressed

    @property
    def n_integer_to_compressed(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was compressed from integer.&#34;&#34;&#34;
        return self._n_integer_to_compressed

    @property
    def n_compressed_to_bitarray(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to bitarray.&#34;&#34;&#34;
        return self._n_compressed_to_bitarray

    @property
    def n_compressed_to_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
        return self._n_compressed_to_integer

    @property
    def n_bitarray_to_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
        return self._n_bitarray_to_integer

    @property
    def n_integer_to_bitarray(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
        return self._n_integer_to_bitarray</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ruleskit.activation.Activation"><code class="flex name class">
<span>class <span class="ident">Activation</span></span>
<span>(</span><span>activation:Union[numpy.ndarray,bitarray.bitarray,str,int,pathlib.Path], optimize:bool=True, length:Optional[int]=None, to_file:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>An activation vector is a 1-D list of 0 and 1 reprenseting the activation of a rule. Each element corresponds to
a line in the features and targets data (typically, a date, or a pair date-object if the data is multi-indexed),
and the vector contains 0 if the condition of the rule is not met at this index in the data and 1 if it is.</p>
<p>When working with lots of data and lots of rules, activation vectors can be hard to keep in memory and can represent
bottlenecks in computation time. This class is designed to reduce the size in memory of the vector and to minimize
the computation time.</p>
<p>An activation vector is an array of 0 and 1, possibly millions of points. The whole purpose of this class is
to efficiently store the vector and allow to use logcial AND easily between two vectors, no matter the stored
format.</p>
<p>The possible storing format are : compressed string or array, integer, bitarray or written on disk.
Activations are written on disk only if 'to_file' is True and Activation.STORE_RAW is False (default).
In that case, the raw np.ndarray vector is stored using np.save.
If the vector is instantiated with any of compressed string or array, integer, bitarray, then this format is
privileged for storing the vector (unless to_file is True or Activation.STORE_RAW is True), but some other flags
like 'optimize' and 'Activation.WILL_COMPARE' can determine the chosen format.</p>
<p>If the raw np.ndarray or a path to it was given and if Activation.STORE_RAW is True, then no formatting is done
and the raw np.ndarray is kept in RAM. This flag has no effect if activation is not the raw np.ndarray nor a
path to it.</p>
<p>Compression : can be either compressed str(list) or np.ndarray, depending on Activation.DTYPE:
Compressed data is : First element of the list is the first value of the array, last element of the list is
the length of the array. The other elements are the coordinates where the array changed values. This is the
best solution regarding the RAM if the vector does not change often. However, it is often slower than the
other methods, particularly if the code will apply logical AND between vectors since it requieres a
decompression of both vectors.
The vector is stored that was if compression is more memory-efficient than integer or bitarray format
OR if optimize is False, or if 'activation' is already a compressed vector.
It is never stored this way if to_file is True or Activation.STORE_RAW is True.
Bitarray :
The input vector [1 0 0 1 0 0 0 1 1&hellip;] where each entry uses up one bit of memory. Takes more RAM than
compressed format if the vector does not change often, but is much quicker, both in conversion and in
computing a logical AND.
The vector is stored that way if it takes less RAM than compressed and if optimize is True and if
Activation.WILL_COMPARE is False (converting to bitarray is faster than to integer, but computing
logical AND on integers is faster). Size is equivalent to integer : one bit per entry. It is also stored
this way if 'activation' is a string and Activation.WILL_COMPARE is False.
It is never stored this way if to_file is True or Activation.STORE_RAW is True.
Integer :
taking the input vector [1 0 0 1 0 0 0 1 1&hellip;], converts it to binary string representation :
"100100011&hellip;" then casts it into int using int(s, 2).
The vector is stored that way if it takes less RAM than compressed and if optimize is True and if
Activation.WILL_COMPARE is True. It is also stored this way if 'activation' is a string and
Activation.WILL_COMPARE is True. It is never stored this way if to_file is True or Activation.STORE_RAW is
True.
File stored locally :
This is done if to_file is True and Activation.STORE_RAW is False (default). It is often the best solution,
and is the default one. Indeed the I/O operations using np.save and np.load are very fast, and the only
thing in RAM is the path to the vector's file. One need enough disk space of course. Using this method will
save the np.array with dtype=np.ubyte, so taking one byte (8 bits) per entry.</p>
<p>If compression is used and dtype is np.ndarray, will check that numbers present in the compressed vector can be
stored as int32 to gain memory. Else, uses int64.</p>
<h2 id="parameters">Parameters:</h2>
<p>activation: Union[np.ndarray, bitarray, str, int, Path]
If np.ndarray : Of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], or compressed vector
If str : compressed vector, or '010011100011111', or path
If bitarray : same as np.array but takes 8x less memory (each entry is stored in one bit only)
If int : as an integer
If Path : read raw np.ndarray vector from path.
optimize: bool
Only relevent if 'value' is a bitarray or an integer. In that case, will check whether using compression
saves up memory. Else, does not check and uses bitarray or integer. Note that if optimize is True, entropy
is computed no matter the chosen format.
length: Optional[int]
Only valid if 'value' is an integer. An activation vector stored as an integer has lost the information
about its size : [0 0 0 1 0 0 0 1 1&hellip;] to int gives 100011&hellip; which in turn gives back [1 0 0 0 1 1&hellip;].
To get the leading zeros back, one must specify the length of the activation vector.
to_file: bool
If True, then activation vector is stored in a file in
Activation.DEFAULT_TEMPDIR / ACTIVATION_VECTOR_available_number.txt if Activation.STORE_RAW
if False (default) (default value = True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Activation(ABC):

    &#34;&#34;&#34;An activation vector is a 1-D list of 0 and 1 reprenseting the activation of a rule. Each element corresponds to
    a line in the features and targets data (typically, a date, or a pair date-object if the data is multi-indexed),
    and the vector contains 0 if the condition of the rule is not met at this index in the data and 1 if it is.

    When working with lots of data and lots of rules, activation vectors can be hard to keep in memory and can represent
    bottlenecks in computation time. This class is designed to reduce the size in memory of the vector and to minimize
    the computation time.
    &#34;&#34;&#34;

    # dtype for the compressed format. Can be str or np.ndarray
    DTYPE = str
    # When calling a profiling attribute that is None, will force the call of the method to compute them if FORCE_STAT
    # is True
    FORCE_STAT = False
    # Should be set to True if the program will do ogical AND between activation vectors in integer format at some point
    WILL_COMPARE = False
    # If activation vectors are to be stored on disk instead of RAM, root directory to store them
    DEFAULT_TEMPDIR = Path(gettempdir())
    # If no formatting should be done, just store raw np.ndarray in RAM
    STORE_RAW = False
    # Number of processes that will be using Activation class. Used when doing memory-intensive operations.
    NCPUS = 1

    &#34;&#34;&#34; Class methods &#34;&#34;&#34;

    @classmethod
    def clean_files(cls):
        &#34;&#34;&#34;Removes activation vector files, if any.&#34;&#34;&#34;
        if not cls.DEFAULT_TEMPDIR.is_dir():
            return
        for path in cls.DEFAULT_TEMPDIR.glob(&#34;ACTIVATION_VECTOR_*.txt&#34;):
            path.unlink()

    &#34;&#34;&#34;Init methods&#34;&#34;&#34;

    def _reset_data_related_attributes(self):

        # Analytical attributes
        self._entropy = None  # Will be set if activation is not an integer or if optimize is True
        self._rel_entropy = None  # Will be set if activation is not an integer or if optimize is True
        self._nones = None  # Will be set if activation is not an integer or if optimize is True
        self._coverage = None

        # Format attributes
        self.length = None  # Will be set by init methods
        self.data = None  # Will be set by init methods

        &#34;&#34;&#34;
        Profiling attribtues. All times are in seconds, all sizes in MB. Attributes starting by &#39;_n_&#39; are counts of
        how many times this or that method triggered.
        &#34;&#34;&#34;

        self._time_write = -1
        self._time_read = -1
        self._time_compressed_to_raw = -1
        self._time_raw_to_compressed = -1
        self._time_raw_to_integer = -1
        self._time_bitarray_to_raw = -1
        self._time_raw_to_bitarray = -1
        self._time_compressed_to_bitarray = -1
        self._time_compressed_to_integer = -1
        self._time_bitarray_to_compressed = -1
        self._time_integer_to_compressed = -1
        self._time_integer_to_raw = -1
        self._time_bitarray_to_integer = -1
        self._time_integer_to_bitarray = -1
        self._n_written = 0
        self._n_read = 0
        self._n_compressed_to_raw = 0
        self._n_raw_to_compressed = 0
        self._n_bitarray_to_raw = 0
        self._n_integer_to_raw = 0
        self._n_raw_to_bitarray = 0
        self._n_raw_to_integer = 0
        self._n_bitarray_to_compressed = 0
        self._n_integer_to_compressed = 0
        self._n_compressed_to_bitarray = 0
        self._n_compressed_to_integer = 0
        self._n_bitarray_to_integer = 0
        self._n_integer_to_bitarray = 0
        self._sizeof_compressed_array = -1
        self._sizeof_compressed_str = -1
        self._sizeof_bitarray = -1
        self._sizeof_integer = -1
        self._sizeof_raw = -1
        self._sizeof_file = -1
        self._sizeof_path = -1

    def __init__(
        self,
        activation: Union[np.ndarray, bitarray, str, int, Path],
        optimize: bool = True,
        length: Optional[int] = None,
        to_file: bool = True,
    ):
        &#34;&#34;&#34;
        An activation vector is an array of 0 and 1, possibly millions of points. The whole purpose of this class is
        to efficiently store the vector and allow to use logcial AND easily between two vectors, no matter the stored
        format.

        The possible storing format are : compressed string or array, integer, bitarray or written on disk.
        Activations are written on disk only if &#39;to_file&#39; is True and Activation.STORE_RAW is False (default).
        In that case, the raw np.ndarray vector is stored using np.save.
        If the vector is instantiated with any of compressed string or array, integer, bitarray, then this format is
        privileged for storing the vector (unless to_file is True or Activation.STORE_RAW is True), but some other flags
        like &#39;optimize&#39; and &#39;Activation.WILL_COMPARE&#39; can determine the chosen format.

        If the raw np.ndarray or a path to it was given and if Activation.STORE_RAW is True, then no formatting is done
        and the raw np.ndarray is kept in RAM. This flag has no effect if activation is not the raw np.ndarray nor a
        path to it.

        Compression : can be either compressed str(list) or np.ndarray, depending on Activation.DTYPE:
            Compressed data is : First element of the list is the first value of the array, last element of the list is
            the length of the array. The other elements are the coordinates where the array changed values. This is the
            best solution regarding the RAM if the vector does not change often. However, it is often slower than the
            other methods, particularly if the code will apply logical AND between vectors since it requieres a
            decompression of both vectors.
            The vector is stored that was if compression is more memory-efficient than integer or bitarray format
            OR if optimize is False, or if &#39;activation&#39; is already a compressed vector.
            It is never stored this way if to_file is True or Activation.STORE_RAW is True.
        Bitarray :
            The input vector [1 0 0 1 0 0 0 1 1...] where each entry uses up one bit of memory. Takes more RAM than
            compressed format if the vector does not change often, but is much quicker, both in conversion and in
            computing a logical AND.
            The vector is stored that way if it takes less RAM than compressed and if optimize is True and if
            Activation.WILL_COMPARE is False (converting to bitarray is faster than to integer, but computing
            logical AND on integers is faster). Size is equivalent to integer : one bit per entry. It is also stored
            this way if &#39;activation&#39; is a string and Activation.WILL_COMPARE is False.
            It is never stored this way if to_file is True or Activation.STORE_RAW is True.
        Integer :
            taking the input vector [1 0 0 1 0 0 0 1 1...], converts it to binary string representation :
            &#34;100100011...&#34; then casts it into int using int(s, 2).
            The vector is stored that way if it takes less RAM than compressed and if optimize is True and if
            Activation.WILL_COMPARE is True. It is also stored this way if &#39;activation&#39; is a string and
            Activation.WILL_COMPARE is True. It is never stored this way if to_file is True or Activation.STORE_RAW is
            True.
        File stored locally :
            This is done if to_file is True and Activation.STORE_RAW is False (default). It is often the best solution,
            and is the default one. Indeed the I/O operations using np.save and np.load are very fast, and the only
            thing in RAM is the path to the vector&#39;s file. One need enough disk space of course. Using this method will
            save the np.array with dtype=np.ubyte, so taking one byte (8 bits) per entry.

        If compression is used and dtype is np.ndarray, will check that numbers present in the compressed vector can be
        stored as int32 to gain memory. Else, uses int64.

        Parameters:
        -----------
        activation: Union[np.ndarray, bitarray, str, int, Path]
            If np.ndarray : Of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], or compressed vector
            If str : compressed vector, or &#39;010011100011111&#39;, or path
            If bitarray : same as np.array but takes 8x less memory (each entry is stored in one bit only)
            If int : as an integer
            If Path : read raw np.ndarray vector from path.
        optimize: bool
            Only relevent if &#39;value&#39; is a bitarray or an integer. In that case, will check whether using compression
            saves up memory. Else, does not check and uses bitarray or integer. Note that if optimize is True, entropy
            is computed no matter the chosen format.
        length: Optional[int]
            Only valid if &#39;value&#39; is an integer. An activation vector stored as an integer has lost the information
            about its size : [0 0 0 1 0 0 0 1 1...] to int gives 100011... which in turn gives back [1 0 0 0 1 1...].
            To get the leading zeros back, one must specify the length of the activation vector.
        to_file: bool
            If True, then activation vector is stored in a file in
            Activation.DEFAULT_TEMPDIR / ACTIVATION_VECTOR_available_number.txt if Activation.STORE_RAW
            if False (default) (default value = True)
        &#34;&#34;&#34;

        self._reset_data_related_attributes()
        self.optimize = optimize
        self.to_file = False  # set by _init_with_any
        self.data_format = None  # Will be set by init methods

        # does not use instance to avoid conflicts if using TransparentPath
        if type(activation) == &#34;str&#34; and &#34;,&#34; not in activation:
            if any([c in activation for c in &#34;abcdefhijklmnopqrstuvwxy./\\&#34;]):  # is a file path
                if TransparentPath is not None:
                    # noinspection PyCallingNonCallable
                    activation = TransparentPath(activation)
                else:
                    activation = Path(activation)
            else:
                if Activation.WILL_COMPARE:
                    activation = int(activation, 2)
                else:
                    activation = bitarray(activation)
        elif isinstance(activation, int) and not Activation.WILL_COMPARE:
            if length is None:
                raise ValueError(&#34;When giving an integer to Activation, you must also specify its length.&#34;)
            self._sizeof_integer = sys.getsizeof(activation) / 1e6
            t0 = time()
            s = bin(activation)[2:]
            if len(s) != length:
                s = &#34;0&#34; * (length - len(s)) + s
            activation = bitarray(s)
            self._time_integer_to_bitarray = time() - t0
            self._n_integer_to_bitarray += 1
            self._sizeof_bitarray = sys.getsizeof(activation) / 1e6
        elif isinstance(activation, bitarray) and Activation.WILL_COMPARE:
            self._sizeof_bitarray = sys.getsizeof(activation) / 1e6
            self._nones = activation.count(1)
            t0 = time()
            if length is None:
                length = len(activation)
            activation = int(
                str(activation).replace(&#34;bitarray(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#39;&#34;&#39;, &#34;&#34;), 2
            )
            self._time_bitarray_to_integer = time() - t0
            self._n_bitarray_to_integer += 1
            self._sizeof_integer = sys.getsizeof(activation) / 1e6

        # noinspection PyTypeChecker
        if isinstance(activation, Path) or TransparentPath is not None and isinstance(activation, TransparentPath):
            activation = self._read(activation, out=False)

        self._init_with_any(activation, length, to_file)

    def _init_with_any(self, activation: Union[np.ndarray, bitarray, int, str], length: int, to_file: bool):
        if isinstance(activation, bitarray):
            self._init_with_bitarray(activation, Activation.DTYPE)

        elif isinstance(activation, int):
            self._init_with_integer(activation, Activation.DTYPE, length)

        elif isinstance(activation, str):
            self._init_with_str(activation)

        elif isinstance(activation, np.ndarray):
            if len(activation) &gt; 0 and activation[-1] &gt; 1:
                self._init_with_compressed_array(activation)
            else:
                if to_file and not self.__class__.STORE_RAW:
                    if not self._write(self.to_raw_from_any(activation, out=False)):
                        self._init_with_any(activation, length=length, to_file=False)
                    else:
                        self.to_file = True
                else:
                    self._init_with_raw(activation, Activation.DTYPE)
        else:
            raise TypeError(
                f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
                f&#34; {type(activation)}.&#34;
            )

    def _write(self, value: np.ndarray):
        &#34;&#34;&#34;Writes the activation vector&#39;s raw np.ndarray to a file in Activation.DEFAULT_TEMPDIR under the name
        ACTIVATION_VECTOR_{n}.txt, where n is a random integer chosen among available numbers from 0 to 1e64.

        Will set:
             * self._sizeof_raw
             * self.length
             * self._nones
             * self._sizeof_file
             * self._sizeof_path
             * self_time_write.
             * self.data to the path to the file
             * self.data_format as &#34;file&#34;
        Will iterate self._n_written.
        &#34;&#34;&#34;
        if value.dtype != np.ubyte:  # Saves memory
            value = value.astype(np.ubyte)
        logger.debug(f&#34;Activation vector is raw, store it in a file&#34;)
        self._sizeof_raw = value.nbytes / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)
        t0 = time()
        arange = list((0, int(1e64)))
        number = random.randint(*arange)
        data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        attempts = 0
        while data.is_file():
            if attempts &gt; 99:
                logger.warning(
                    &#34;Failed to save activation vector locally after 100 attempts at finding an available&#34;
                    &#34; name. Will keep it in RAM.&#34;
                )
                return False
            number += 1
            attempts += 1
            arange.remove(number)
            number = random.randint(*arange)
            data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        data.touch()
        self.data = data
        self.data_format = &#34;file&#34;
        with open(self.data, &#34;wb&#34;) as f:
            # noinspection PyTypeChecker
            np.save(f, value, allow_pickle=False)
        stat = self.data.stat()
        if isinstance(stat, dict):
            self._sizeof_file = stat[&#34;st_size&#34;] / 1e6
        else:
            self._sizeof_file = stat.st_size / 1e6
        self._sizeof_path = sys.getsizeof(self.data) / 1e6
        self._time_write = time() - t0
        self._n_written += 1
        return True

    def _init_with_bitarray(self, value: bitarray, dtype: type):

        &#34;&#34;&#34;
        Will set
            * self._nones (number of ones in the activation)
            * self.length
            * self._sizeof_bitarray
            if self.optimize is True:
                  * self._entropy and self._rel_entropy
                  * self.data_format to &#34;bitarray&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes
                    less memory
                  * self.data as a bitarray, a str or an array
                  Will iterate self._n_bitarray_to_compressed
            else:
                  * self.data as a bitarray
                  * self.data_format to &#34;bitarray&#34;
        &#34;&#34;&#34;

        logger.debug(f&#34;Activation vector is a bitarray&#34;)
        self.length = len(value)
        self._sizeof_bitarray = sys.getsizeof(value) / 1e6
        self._nones = value.count(1)

        if self.optimize:
            t0 = time()
            raw = self._bitarray_to_raw(value, out=False)
            t1 = time()
            compressed = self._compress(raw, dtype=dtype)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = compressed.nbytes / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed))
            else:
                self._entropy = len(compressed)
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_bitarray:
                self.data = value
                self.data_format = &#34;bitarray&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;bitarray&#34;

    def _init_with_integer(self, value: int, dtype: type, length: Optional[int] = None):

        &#34;&#34;&#34;
        Will set
            * self.length
            * self._sizeof_integer
            if self.optimize is True:
                * self._nones (number of ones in the activation)
                * self._entropy and self._rel_entropy
                * self.data_format to &#34;integer&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes less
                memory
                * self.data as an integer, a str or an np.ndarray
                Will iterate self._n_integer_to_compressed
            else:
                * self.data as an integer
                * self.data_format to &#34;integer&#34;
        &#34;&#34;&#34;

        if length is None:
            raise ValueError(&#34;When giving an integer to Activation, you must also specify its length.&#34;)

        logger.debug(f&#34;Activation vector is an int&#34;)
        self.length = length
        self._sizeof_integer = sys.getsizeof(value) / 1e6

        if self.optimize:
            t0 = time()
            raw = self._integer_to_raw(value, out=False)
            self._nones = np.count_nonzero(raw == 1)
            t1 = time()
            compressed = self._compress(raw, dtype=dtype)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = compressed.nbytes / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed))
            else:
                self._entropy = len(compressed)
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_integer:
                self.data = value
                self.data_format = &#34;integer&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;integer&#34;

    def _init_with_str(self, value: str):
        &#34;&#34;&#34;
        will set :
            * self.data as a compressed str
            * self._sizeof_compressed_str
            * self.data_format as &#34;compressed_str&#34;
            * self._entropy and self._rel_entropy
            * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed str&#34;)
        evaluated = np.array(ast.literal_eval(value))
        self.data = value
        self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        self._entropy = len(evaluated)
        self.length = evaluated[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_str&#34;

    def _init_with_compressed_array(self, value: np.ndarray):
        &#34;&#34;&#34;
        will set :
            * self.data as a compressed array
            * self._sizeof_compressed_array
            * self.data_format as &#34;compressed_array&#34;
            * self._entropy and self._rel_entropy
            * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed array&#34;)
        self.data = value
        self._sizeof_compressed_array = value.nbytes / 1e6
        self._entropy = len(value)
        self.length = value[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_array&#34;

    def _init_with_raw(self, value: np.ndarray, dtype: type):
        &#34;&#34;&#34;
        will set :
            * self.data as an integer or a compressed array/str depending on what takes less memory and on what dtype is
            * self._sizeof_compressed_str or self._sizeof_compressed_array if Activation.STORE_RAW is False
            * self._sizeof_raw
            * self._time_raw_to_compressed if Activation.STORE_RAW is False
            * self._time_raw_to_bitarray or integer if Activation.STORE_RAW is False
            * self._sizeof_bitarray or integer if Activation.STORE_RAW is False
            * self.data_format as &#34;bitarray&#34;, &#34;integer&#34;, &#34;raw&#34; or &#34;compressed_array&#34; or &#34;compressed_str&#34;
            * self._entropy and self._rel_entropy
            * self.length
            * self._nones
        Will iterate :
            * self._n_raw_to_bitarray or integer if Activation.STORE_RAW is False
            * self._n_raw_to_compressed if Activation.STORE_RAW is False
        &#34;&#34;&#34;
        if value.dtype != np.ubyte:
            value = value.astype(np.ubyte)
        logger.debug(f&#34;Activation vector is raw&#34;)
        self._sizeof_raw = value.nbytes / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)

        if Activation.STORE_RAW:
            self.data = value
            self.data_format = &#34;raw&#34;
            return

        t0 = time()
        compressed = self._compress(value, dtype=dtype)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if isinstance(compressed, str):
            self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            size_compressed = self._sizeof_compressed_str
        else:
            self._sizeof_compressed_array = compressed.nbytes / 1e6
            size_compressed = self._sizeof_compressed_array
        if dtype is str:
            self._entropy = len(ast.literal_eval(compressed))
        else:
            self._entropy = len(compressed)
        self._rel_entropy = self._entropy / self.length
        t0 = time()
        if Activation.WILL_COMPARE:
            inbit = self._raw_to_integer(value)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            self._sizeof_integer = sys.getsizeof(inbit) / 1e6
            thesize = self._sizeof_integer
            s = f&#34;Using integer activation representation&#34;
            fmt = &#34;integer&#34;
        else:
            inbit = self._raw_to_bitarray(value)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            self._sizeof_bitarray = sys.getsizeof(inbit) / 1e6
            thesize = self._sizeof_bitarray
            s = f&#34;Using bitarray activation representation&#34;
            fmt = &#34;bitarray&#34;
        if thesize &gt; size_compressed:
            logger.debug(f&#34;Using compressed activation representation&#34;)
            self.data = compressed
            if dtype == str:
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
        else:
            logger.debug(s)
            self.data_format = fmt
            self.data = inbit

    &#34;&#34;&#34; Binary operators &#34;&#34;&#34;

    def __and__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;logical AND of two activation vectors. Only valid if both have the same length. Both vectors DO NOT need
        to have the same format.&#34;&#34;&#34;
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):  # gains time by not using raw
            return Activation(self.data &amp; a2.data, optimize=self.optimize and a2.optimize, to_file=False)
        else:
            return Activation(
                self.raw * a2.raw,
                optimize=self.optimize and a2.optimize,
                to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;,
            )

    @staticmethod
    def multi_logical_and(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
        &#34;&#34;&#34;Do LOGICAL AND on many activation vectors at once. Uses raw np.ndarrays to gain time.
        If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;

        available_memory = psutil.virtual_memory().available / 1e6
        single_act_size = acs[0].sizeof_raw
        expected_size = single_act_size * len(acs) * Activation.NCPUS * 1.1  # factor 1.1 is just for safety
        if available_memory == 0:
            raise ValueError(&#34;No memory left to compute &#39;multi_logical_and&#39;&#34;)
        nbatches = ceil(expected_size / available_memory)
        if nbatches == 0:
            raise ValueError(
                f&#34;Not enough memory left to compute &#39;multi_logical_and&#39; : need {expected_size}MB,&#34;
                f&#34; has {available_memory}MB&#34;
            )
        batches = np.array_split(acs, nbatches)

        if len(acs) == 1:
            res = acs[0].raw
        else:
            if 2 * single_act_size &gt; available_memory:
                raise MemoryError(&#34;Will not be able to fit two activation vectors of size&#34;
                                  f&#34; {acs[0].sizeof_raw} in memory&#34;)
            res = []
            for batch in batches:
                res = np.vstack([a.raw for a in batch]).all(axis=0).astype(np.ubyte)
            res = np.vstack([a for a in res]).all(axis=0).astype(np.ubyte)
        if asarray:
            return res
        return Activation(
            res,
            optimize=all([a.optimize for a in acs]),
            to_file=all([a.data_format == &#34;file&#34; for a in acs]),
        )

    def __or__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;LOGICAL OR of two activation vectors. Only valid if both have the same length. Both vectors DO NOT need
        to have the same format.&#34;&#34;&#34;
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):  # gains time by not using raw
            return Activation(self.data | a2.data, optimize=self.optimize and a2.optimize, to_file=False)
        else:
            return Activation(
                self.raw | a2.raw,
                optimize=self.optimize and a2.optimize,
                to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;,
            )

    @staticmethod
    def multi_logical_or(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
        &#34;&#34;&#34;Do LOGICAL OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
        If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;

        available_memory = psutil.virtual_memory().available / 1e6
        single_act_size = acs[0].sizeof_raw
        expected_size = single_act_size * len(acs) * Activation.NCPUS * 1.1  # factor 1.1 is just for safety
        if available_memory == 0:
            raise MemoryError(&#34;No memory left to compute &#39;multi_logical_or&#39;&#34;)
        nbatches = ceil(expected_size / available_memory)
        if nbatches == 0:
            raise MemoryError(
                f&#34;Not enough memory left to compute &#39;multi_logical_or&#39; : need {expected_size}MB,&#34;
                f&#34; has {available_memory}MB&#34;
            )
        batches = np.array_split(acs, nbatches)

        if len(acs) == 1:
            res = acs[0].raw
        else:
            if 2 * single_act_size &gt; available_memory:
                raise MemoryError(&#34;Will not be able to fit two activation vectors of size&#34;
                                  f&#34; {acs[0].sizeof_raw} in memory&#34;)
            res = []
            for batch in batches:
                res.append(np.vstack([a.raw for a in batch]).any(axis=0).astype(np.ubyte))
            res = np.vstack([a for a in res]).any(axis=0).astype(np.ubyte)
        if asarray:
            return res
        return Activation(
            res,
            optimize=all([a.optimize for a in acs]),
            to_file=all([a.data_format == &#34;file&#34; for a in acs]),
        )

    def __xor__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;Logcial EXCLUSIVE OR of two activation vectors. Only valid if both have the same length. Both vectors DO NOT
        need to have the same format.&#34;&#34;&#34;
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):  # gains time by not using raw
            return Activation(self.data ^ a2.data, optimize=self.optimize and a2.optimize, to_file=False)
        else:
            return Activation(
                self.raw ^ a2.raw,
                optimize=self.optimize and a2.optimize,
                to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;,
            )

    @staticmethod
    def multi_logical_xor(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
        &#34;&#34;&#34;Do LOGICAL EXCLUSIVE OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
        If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;
        if len(acs) == 1:
            return Activation(acs[0].raw, optimize=acs[0].optimize, to_file=acs[0].data_format == &#34;file&#34;)
        lor = Activation.multi_logical_or(acs, True)
        nland = -(Activation.multi_logical_and(acs, True) - 1)
        res = lor &amp; nland.astype(np.ubyte)
        if asarray:
            return res
        return Activation(
            res,
            optimize=all([a.optimize for a in acs]),
            to_file=all([a.data_format == &#34;file&#34; for a in acs]),
        )

    def __add__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;Synonym of logical OR&#34;&#34;&#34;
        return self or other

    def __sub__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        &#34;&#34;&#34;Logical EXCLUSIVE OR then logical AND&#34;&#34;&#34;
        return (self ^ other) &amp; self

    &#34;&#34;&#34; Other methods &#34;&#34;&#34;

    def __copy__(self) -&gt; &#34;Activation&#34;:
        if self.data_format == &#34;integer&#34;:
            return Activation(copy(self.data), optimize=self.optimize, length=self.length)
        return Activation(copy(self.data), optimize=self.optimize, to_file=self.data_format == &#34;file&#34;)

    def clear(self):
        &#34;&#34;&#34;Fill Activation with zeros&#34;&#34;&#34;
        data = np.zeros(self.length)
        self._reset_data_related_attributes()
        self._init_with_raw(data, Activation.DTYPE)

    def delete(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, either by deleting the local file or by calling del on self.data. In
        the later case, self.data is reset to None.&#34;&#34;&#34;
        if self.data_format == &#34;file&#34;:
            if self.data.is_file():
                self.data.unlink()
        else:
            del self.data
            self.data = None

    def __len__(self):
        &#34;&#34;&#34;Number of points in the vector&#34;&#34;&#34;
        return self.length

    def __contains__(self, other: &#34;Activation&#34;) -&gt; bool:
        intersection = self &amp; other
        nones_intersection = intersection.nones
        intersection.delete()
        if nones_intersection &lt; min(self.nones, other.nones):
            return False
        return True

    def get_correlation(self, other: &#34;Activation&#34;) -&gt; float:
        &#34;&#34;&#34; Computes the correlation between self and other
        Correlation is the number of points in common between the two vectors divided by their length.
        Both vectors must have the same length.
        &#34;&#34;&#34;
        if not len(self) == len(other):
            raise ValueError(&#34;Both vectors must have the same length&#34;)

        common_points = np.count_nonzero(self.raw == other.raw)
        return common_points / len(self)

    &#34;&#34;&#34; Conversions to raw methods&#34;&#34;&#34;

    def to_raw_from_any(self, activation, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;Converts any format among integer, bitarray, compressed string or compressed array to raw activation
        vector np.ndarray&#34;&#34;&#34;
        if isinstance(activation, bitarray):
            raw = self._bitarray_to_raw(activation, out=out)
        elif isinstance(activation, int):
            raw = self._integer_to_raw(activation, out=out)
        elif isinstance(activation, (str, np.ndarray)):
            raw = self._decompress(activation, raw=True, out=out)
        else:
            raise TypeError(
                f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
                f&#34; {type(activation)}.&#34;
            )
        return raw

    def _read(self, path: Optional[TransparentPath] = None, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;Read a raw activation vector&#39;s np.ndarray, either from given path, or from self.data. In that case, will
        raise ValueError if self.data_format is not &#34;file&#34;.

        If out is not True or value is None, will set:
            * self._sizeof_raw
            * self._nones
            * self._time_read
            * self._sizeof_file
            * self._sizeof_path
            Will iterate self._n_read
        &#34;&#34;&#34;
        if path is None:
            out = False
            if not self.data_format == &#34;file&#34;:
                raise ValueError(&#34;Activation vector was not saved locally : can not read it.&#34;)
            path = self.data
        t0 = time()
        with open(path, &#34;rb&#34;) as f:
            # noinspection PyTypeChecker
            value = np.load(f)
        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = value.nbytes / 1e6
            if self._nones is None:
                self._nones = np.count_nonzero(value == 1)
            stat = path.stat()
            if isinstance(stat, dict):
                self._sizeof_file = stat[&#34;st_size&#34;] / 1e6
            else:
                self._sizeof_file = stat.st_size / 1e6
            self._sizeof_path = sys.getsizeof(self.data) / 1e6
            self._time_read = time() - t0
            self._n_read += 1
        return value

    def _integer_to_raw(self, value: Optional[int] = None, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;From a value of the form 45786542 (int), which is the base 10 representation of the binary form of an
        activation vector, returns the raw np.ndarray vector of the form [1, 0, 0, 1, 1, 0, ...].

        If out is not True or value is None, will set:
            * self._sizeof_integer
            * self._sizeof_raw
            * self._time_integer_to_raw
            * self._nones
            Will iterate :
                * self._n_integer_to_raw
        &#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (len(value) == 0 or value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_integer_to_raw = time() - t0
                self._n_integer_to_raw += 1
            return value

        if isinstance(value, (bitarray, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _integer_to_raw on a bitarray, raw, compressed or a path&#34;)
        if not isinstance(value, int):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.fromiter(bin(value)[2:], dtype=np.ubyte)
        if not out:
            self._sizeof_integer = sys.getsizeof(value) / 1e6

        if len(act) &gt; self.length:
            raise ValueError(
                &#34;After using _integer_to_raw, I ended up with an activation vector bigger than the specified &#34;
                &#34;max length. This should not happend as the max length should have been set by the indexing &#34;
                &#34;of x earlier in your code&#34;
            )
        act_bis = np.zeros(self.length).astype(np.ubyte)
        act_bis[self.length - len(act):] = act

        if not out:
            self._sizeof_raw = act_bis.nbytes / 1e6
            self._time_integer_to_raw = time() - t0
            self._n_integer_to_raw += 1
            if self._nones is None:
                self._nones = np.count_nonzero(act_bis == 1)
        return act_bis

    def _bitarray_to_raw(self, value: Union[bitarray, Path] = None, out=True) -&gt; np.ndarray:
        &#34;&#34;&#34;Transforms a bitarray to a np.ndarray

        If out is not True or value is None, will set:
            * self._sizeof_bitarray
            * self._sizeof_raw
            * self._time_bitarray_to_raw
            * self._nones
            Will iterate :
                * self._n_bitarray_to_raw
        &#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (len(value) == 0 or value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_bitarray_to_raw = time() - t0
                self._n_bitarray_to_raw += 1
            return value

        if isinstance(value, (int, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _bitarray_to_raw on a raw, integer, compressed or a path&#34;)
        if not isinstance(value, bitarray):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.array(list(value), dtype=np.ubyte)

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = act.nbytes / 1e6
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(value) / 1e6
            self._time_bitarray_to_raw = time() - t0
            self._n_bitarray_to_raw += 1
        return act

    def _decompress(
        self, value: Union[str, np.ndarray, Path] = None, raw=True, out=True
    ) -&gt; Union[np.ndarray, bitarray, int]:
        &#34;&#34;&#34;From a compressed array of either str or np.ndarray format, will return the raw np.ndarray vector of the form
        [0, 1, 1, 1, 0, 0, 1, ...]

        If raw is True (default), returns it as a np.ndarray, else as a bitarray

        If out is False or value is None, will set:
            * self._time_compressed_to_raw
            * self._sizeof_compressed_str or _sizeof_compressed_array
            * self._sizeof_raw
            * self._nones
            Will iterate :
                * self._n_compressed_to_raw
        raw if False and Activation.WILL_COMPARE is True/False:
            * self._time_compressed_to_integer/bitarray
            * self._sizeof_nteger/bitarray
            Will iterate :
                * self._n_compressed_to_nteger/bitarray
        &#34;&#34;&#34;
        t0 = time()

        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, (int, bitarray, Path)):
            raise TypeError(&#34;Can not apply _decompress on a bitarray, integer or Path&#34;)
        if not isinstance(value, (str, np.ndarray)):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)

        if len(value) == 0:
            if isinstance(value, np.ndarray):  # is already raw
                if not out:
                    self._sizeof_raw = value.nbytes / 1e6
                    if self._nones is None:
                        self._nones = np.count_nonzero(value == 1)
                return value
            else:
                if not out:
                    self._sizeof_raw = np.array([]).nbytes / 1e6
                    self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
                    if self._nones is None:
                        self._nones = 0
                return np.array([])
        if value[-1] == 0 or value[-1] == 1:  # is already raw
            if not out:
                self._sizeof_raw = value.nbytes / 1e6
                if self._nones is None:
                    self._nones = np.count_nonzero(value == 1)
            return value

        if isinstance(value, str):
            act = ast.literal_eval(value)
            if not out:
                self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        elif isinstance(value, np.ndarray):
            act = value
            if not out:
                self._sizeof_compressed_array = value.nbytes / 1e6
        else:
            raise TypeError(f&#34;&#39;value&#39; can not be of type {type(value)}&#34;)

        length = act[-1]
        s = np.zeros(length, dtype=np.ubyte)
        previous_value = 0
        previous_index = 0

        if act[0] == 1:
            previous_value = 1
            s[0] = 1
        if len(act) == 2:
            if act[0] == 1:
                s = np.ones(length, dtype=np.ubyte)
        else:
            for index in act[1:]:
                if previous_value == 0:
                    previous_index = index
                    previous_value = 1
                else:
                    s[previous_index:index] = np.ones(index - previous_index)
                    previous_index = index
                    previous_value = 0
        s = np.array(s, dtype=np.ubyte)

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = s.nbytes / 1e6
            self._time_compressed_to_raw = time() - t0
            self._n_compressed_to_raw += 1
            if self._nones is None:
                self._nones = np.count_nonzero(s == 1)

        if raw:
            act = s
            fmt = &#34;raw&#34;
        elif Activation.WILL_COMPARE:
            t1 = time()
            act = self._raw_to_integer(s)
            if not out:
                self._time_raw_to_integer = time() - t1
                self._n_raw_to_integer += 1
            fmt = &#34;integer&#34;
        else:
            t1 = time()
            # noinspection PyTypeChecker
            act = self._raw_to_bitarray(s)
            if not out:
                self._time_raw_to_bitarray = time() - t1
                self._n_raw_to_bitarray += 1
            fmt = &#34;bitarray&#34;

        if not out:
            if fmt == &#34;integer&#34;:
                # noinspection PyTypeChecker
                if self._sizeof_integer == -1:
                    self._sizeof_integer = sys.getsizeof(act) / 1e6
                self._time_compressed_to_integer = time() - t0
                self._n_compressed_to_integer += 1
            elif fmt == &#34;bitarray&#34;:
                # noinspection PyTypeChecker
                if self._sizeof_bitarray == -1:
                    self._sizeof_bitarray = sys.getsizeof(act) / 1e6
                self._time_compressed_to_bitarray = time() - t0
                self._n_compressed_to_bitarray += 1
        return act

    &#34;&#34;&#34; Conversions from raw methods&#34;&#34;&#34;

    @staticmethod
    def _compress(value: Union[np.ndarray, str], dtype: type = str) -&gt; Union[np.ndarray, str]:
        &#34;&#34;&#34;Transforms a raw or bitarray activation vector to a compressed one.

        A compressed vector is a collection of integers starting by the initial value of the raw vector (0 or 1) and
        ending with its length. The other integers in the compression are the positions in the raw vector where the
        vector value changes. This stores all the information and saves up memory if the vector is constant over
        large periods of time.

        The compressed vector can be stored as a str looking like &#34;0, 12, 456, ..., 47782&#34; or as a numpy array of
        integers. What storage to use is specified by the &#34;dtype&#34; argument.
        &#34;&#34;&#34;
        if isinstance(value, (int, bitarray)):
            raise TypeError(&#34;Can not compress an integer vector&#34;)
        if not isinstance(value, np.ndarray) or (len(value) &gt; 0 and value[-1] != 0 and value[-1] != 1):
            if isinstance(value, str) and dtype != str:
                return np.array(value.split(&#34;,&#34;)).astype(np.ubyte)
            return value
        if isinstance(value, np.ndarray):
            # not ubyte (unsigned byte), because np.diff will produce negative value that ubyte can not handle
            value = value.astype(np.byte)
            if len(value) == 0:
                return np.array([])
        else:
            raise TypeError(f&#34;Can not compress a {type(value)}&#34;)
        to_ret = [value[0]]
        diff_arr = abs(np.diff(value))
        to_ret += list(np.where(diff_arr == 1)[0] + 1)
        to_ret.append(len(value))
        if dtype == str:
            to_ret = str(to_ret).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
        else:
            if to_ret[-1] &lt; MAX_INT_32:
                to_ret = np.array(to_ret, dtype=&#34;int32&#34;)
            else:
                to_ret = np.array(to_ret, dtype=&#34;int64&#34;)
        return to_ret

    @staticmethod
    def _raw_to_bitarray(value: np.ndarray) -&gt; bitarray:
        &#34;&#34;&#34;Casts a raw activation vector into a bitarray, dividing its size in MO by 8.&#34;&#34;&#34;
        if isinstance(value, bitarray):
            return value
        elif not isinstance(value, np.ndarray) or (len(value) &gt; 0 and value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a compressed vector&#34;)
        elif isinstance(value, int):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a integer vector&#34;)
        # noinspection PyTypeChecker
        return bitarray(value.tolist())

    @staticmethod
    def _raw_to_integer(value: np.ndarray) -&gt; int:
        &#34;&#34;&#34;Casts a raw activation vector into the integer represented by its binary form, dividing its size in MO by 8.

        Examples
        --------
        &gt;&gt;&gt; from ruleskit import Activation
        &gt;&gt;&gt; Activation._raw_to_integer(np.array([0, 1, 1, 0]))
        6  # the binary number &#39;0110&#39; is 6 in base 10
        &#34;&#34;&#34;
        if isinstance(value, int):
            return value
        elif not isinstance(value, np.ndarray) or (len(value) &gt; 0 and value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_integer or a compressed vector&#34;)
        elif isinstance(value, bitarray):
            raise TypeError(&#34;Can not use _raw_to_integer on a bitarray vector&#34;)
        to_ret = int(&#34;&#34;.join(str(i) for i in value.astype(np.ubyte)), 2)
        return to_ret

    &#34;&#34;&#34;properties&#34;&#34;&#34;

    @property
    def ones(self) -&gt; np.ndarray:
        &#34;&#34;&#34;ones is the list of indexes where the vector is 1
        Contrary to other @properties, do not store &#39;ones&#39; in self, for it can be quit large : several MB or more.
        When running codes with millions of vector, this can be problematic.&#34;&#34;&#34;
        raw = self.raw
        ones = np.where(raw == 1)[0].tolist()
        return ones

    @property
    def nones(self) -&gt; int:
        &#34;&#34;&#34;nones is the number of points where the activation vector is 1
        self._nones might not be set since it can only be set at object creation if the full array was given or
        accessed at some point
        &#34;&#34;&#34;
        if self._nones is None:
            _ = self.raw  # calling raw will compute nones

        if self._coverage is None:
            self._coverage = self._nones / self.length
        return self._nones

    @property
    def entropy(self) -&gt; int:
        &#34;&#34;&#34;The entropy of the vector is the length of its compressed reprensentation : the number of times it switched
        from 1 to 0 and vice versa, plus 1 for the information about its initial value, and again 1 for the Information
        about its size.
        Like self._nones, it might not have been computed yet. In that case, compute it.

        If entropy is ocmputed here, will set:
            * self._time_bitarray_to_compressed or self._time_integer_to_compressed
            * self._sizeof_compressed_str or self._sizeof_compressed_array
            * self._entropy (you don&#39;t say)
            * self._rel_entropy
            Will iterate :
                * self._n_bitarray_to_compressed or self._n_integer_to_compressed
        &#34;&#34;&#34;
        if self._entropy is None:
            t0 = time()
            fmt = self.data_format
            if self.data_format == &#34;file&#34;:
                data = self._read(out=False)
                fmt = &#34;raw&#34;
            else:
                data = self.data

            if fmt == &#34;bitarray&#34;:
                data = self._bitarray_to_raw(data, out=False)
                compressed = self._compress(data)
                self._time_bitarray_to_compressed = time() - t0
                self._n_bitarray_to_compressed += 1
            elif fmt == &#34;integer&#34;:
                data = self._integer_to_raw(data, out=False)
                compressed = self._compress(data)
                self._time_integer_to_compressed = time() - t0
                self._n_integer_to_compressed += 1
            elif fmt == &#34;raw&#34;:
                compressed = self._compress(data)
                self._time_raw_to_compressed = time() - t0
                self._n_raw_to_compressed += 1
            else:
                raise ValueError(f&#34;Entropy should have been computed already if format is {fmt}&#34;)

            if self.data_format == &#34;compressed_str&#34;:
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            if self.data_format == &#34;compressed_array&#34;:
                self._sizeof_compressed_array = compressed.nbytes / 1e6

            self._entropy = len(ast.literal_eval(compressed))
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return self._entropy

    @property
    def rel_entropy(self) -&gt; float:
        &#34;&#34;&#34;Relative entropy is the entropy divided by the length of the raw np.ndarray vector
        Like self._nones, it might not have been computed yet. In that case, compute it.
        &#34;&#34;&#34;
        if self._rel_entropy is None:
            _ = self.entropy  # will set self._rel_entropy
        return self._rel_entropy

    @property
    def coverage(self) -&gt; float:
        &#34;&#34;&#34;Coverage is the fraction of points equal to 1 in the vector
        Like self._nones, it might not have been computed yet. In that case, compute it.
        &#34;&#34;&#34;
        if self._coverage is None:
            _ = self.nones  # will set self._coverage
        return self._coverage

    &#34;&#34;&#34;Method to access various formats&#34;&#34;&#34;

    @property
    def raw(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the raw np.ndarray. Will set relevant profiling attributes.&#34;&#34;&#34;
        if self.data_format == &#34;raw&#34;:
            return self.data
        elif self.data_format == &#34;bitarray&#34;:
            return self._bitarray_to_raw(out=False)
        elif self.data_format == &#34;integer&#34;:
            return self._integer_to_raw(out=False)
        elif self.data_format == &#34;file&#34;:
            return self._read(out=False)
        elif &#34;compressed&#34; in self.data_format:
            return self._decompress(out=False)
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_bitarray(self) -&gt; bitarray:
        &#34;&#34;&#34;Returns the bitarray representation of the vector&#34;&#34;&#34;
        if self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            t0 = time()
            to_ret = self._raw_to_bitarray(data)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._raw_to_bitarray(self.data)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            return self.data
        elif self.data_format == &#34;integer&#34;:
            t0 = time()
            s = bin(self.data)[2:]
            if len(s) != self.length:
                s = &#34;0&#34; * (self.length - len(s)) + s
            to_ret = bitarray(s)
            self._time_integer_to_bitarray = time() - t0
            self._n_integer_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif &#34;compressed&#34; in self.data_format:
            wc = Activation.WILL_COMPARE
            Activation.WILL_COMPARE = False
            to_ret = self._decompress(raw=False, out=False)
            Activation.WILL_COMPARE = wc
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the integer representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;

        if self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            t0 = time()
            to_ret = self._raw_to_integer(data)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._raw_to_integer(self.data)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif self.data_format == &#34;integer&#34;:
            return self.data
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = int(str(self.data).replace(&#34;bitarray(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#39;&#34;&#39;, &#34;&#34;), 2)
            self._time_bitarray_to_integer = time() - t0
            self._n_bitarray_to_integer += 1
            self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
            return to_ret
        elif &#34;compressed&#34; in self.data_format:
            wc = Activation.WILL_COMPARE
            Activation.WILL_COMPARE = True
            to_ret = self._decompress(raw=False, out=False)
            Activation.WILL_COMPARE = wc
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_compressed(self) -&gt; Union[str]:
        &#34;&#34;&#34;Returns the compressed str representation of the vector.
        Will set relevant profiling attributes.&#34;&#34;&#34;
        return self.as_compressed_str

    @property
    def as_compressed_array(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the compressed array representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;
        if self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;compressed_array&#34;:
            to_ret = self.data
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;compressed_str&#34;:
            to_ret = np.array(ast.literal_eval(self.data))
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;integer&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = to_ret.nbytes / 1e6
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            t0 = time()
            to_ret = self._compress(data, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)
        self._entropy = len(to_ret)
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return to_ret

    @property
    def as_compressed_str(self) -&gt; str:
        &#34;&#34;&#34;Returns the compressed str representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;
        if self.data_format == &#34;raw&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=str)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;compressed_str&#34;:
            to_ret = self.data
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;compressed_array&#34;:
            to_ret = str(self.data.tolist()).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;integer&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=str)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            raw = self.raw
            t1 = time()
            to_ret = self._compress(raw, dtype=str)
            self._time_raw_to_compressed = time() - t1
            self._n_raw_to_compressed += 1
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
        elif self.data_format == &#34;file&#34;:
            t0 = time()
            data = self._read(out=False)
            to_ret = self._compress(data, dtype=str)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)
        self._entropy = len(ast.literal_eval(to_ret))
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return to_ret

    @property
    def sizeof_path(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the path object, or -1 if it does not exist.
        In that case and if Activation.FORCE_STAT is True, will force the object to write the file to compute the
         relevant profiling attributes.&#34;&#34;&#34;
        if self._sizeof_path == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._sizeof_path

    @property
    def sizeof_file(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the path object, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._sizeof_file == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._sizeof_file

    @property
    def sizeof_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of raw np.ndarray vector, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.raw to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._sizeof_raw == -1 and Activation.FORCE_STAT:
            _ = self.raw
        return self._sizeof_raw

    @property
    def sizeof_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in bitarray, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_bitarray to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_bitarray == -1 and Activation.FORCE_STAT:
            _ = self.as_bitarray
        return self._sizeof_bitarray

    @property
    def sizeof_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in integer, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_integer to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_integer == -1 and Activation.FORCE_STAT:
            _ = self.as_integer
        return self._sizeof_integer

    @property
    def sizeof_compressed_array(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in compressed array, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_compressed_array to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_compressed_array == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_array
        return self._sizeof_compressed_array

    @property
    def sizeof_compressed_str(self) -&gt; float:
        &#34;&#34;&#34;Returns the size in MB of the vector in compressed str, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self.as_compressed_str to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._sizeof_compressed_str == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_str
        return self._sizeof_compressed_str

    @property
    def time_write(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to write the vector to a file, or -1 if it does not exist. In that case and
        if Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._time_write == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._time_write

    @property
    def time_read(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to read the vector to a file, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._time_read == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self._write(self.raw)
            _ = self._read(self.data, out=False)
            self.data.unlink()
            self.data = data
            self.data_format = fmt
        return self._time_read

    @property
    def time_raw_to_compressed(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._compress to compute the relevant profiling
        attributes.&#34;&#34;&#34;
        if self._time_raw_to_compressed == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.raw
            self.data_format = &#34;raw&#34;
            _ = self.as_compressed
            self.data = data
            self.data_format = fmt
        return self._time_raw_to_compressed

    @property
    def time_raw_to_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds go from raw to integer, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._raw_to_integer to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_raw_to_integer == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.raw
            self.data_format = &#34;raw&#34;
            _ = self.as_integer
            self.data = data
            self.data_format = fmt
        return self._time_raw_to_integer

    @property
    def time_raw_to_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds go from raw to bitarray, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._raw_to_bitarray to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_raw_to_bitarray == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.raw
            self.data_format = &#34;raw&#34;
            _ = self.as_bitarray
            self.data = data
            self.data_format = fmt
        return self._time_raw_to_bitarray

    @property
    def time_compressed_to_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._decompress to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_compressed_to_raw == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_compressed
            if isinstance(self.data, str):
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
            _ = self.raw
            self.data = data
            self.data_format = fmt
        return self._time_compressed_to_raw

    @property
    def time_bitarray_to_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to raw, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._bitarray_to_raw to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_bitarray_to_raw == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_bitarray
            self.data_format = &#34;bitarray&#34;
            _ = self.raw
            self.data = data
            self.data_format = fmt
        return self._time_bitarray_to_raw

    @property
    def time_integer_to_raw(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from integer to raw, or -1 if it does not exist. In that case and if
        Activation.FORCE_STAT is True, will force the object to call self._integer_to_raw to compute the relevant
        profiling attributes.&#34;&#34;&#34;
        if self._time_integer_to_raw == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_integer
            self.data_format = &#34;integer&#34;
            _ = self.raw
            self.data = data
            self.data_format = fmt
        return self._time_integer_to_raw

    @property
    def time_compressed_to_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from compressed to bitarray, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._decompress on self.as_compressed with
         &#39;raw=False&#39; to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_compressed_to_bitarray == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_compressed
            if isinstance(self.data, str):
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
            _ = self.as_bitarray
            self.data = data
            self.data_format = fmt
        return self._time_compressed_to_bitarray

    @property
    def time_bitarray_to_compressed(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to compressed, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._compress on self.as_bitarray to
        compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_bitarray_to_compressed == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_bitarray
            self.data_format = &#34;bitarray&#34;
            _ = self.as_compressed
            self.data = data
            self.data_format = fmt
        return self._time_bitarray_to_compressed

    @property
    def time_integer_to_compressed(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from integer to compressed, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._compress on
        self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_integer_to_compressed == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_integer
            self.data_format = &#34;integer&#34;
            _ = self.as_compressed
            self.data = data
            self.data_format = fmt
        return self._time_integer_to_compressed

    @property
    def time_bitarray_to_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self._compress on
        self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_bitarray_to_integer == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_bitarray
            self.data_format = &#34;bitarray&#34;
            _ = self.as_integer
            self.data = data
            self.data_format = fmt
        return self._time_bitarray_to_integer

    @property
    def time_integer_to_bitarray(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self.as_integer on
        self to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_integer_to_bitarray == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_integer
            self.data_format = &#34;integer&#34;
            _ = self.as_bitarray
            self.data = data
            self.data_format = fmt
        return self._time_integer_to_bitarray

    @property
    def time_compressed_to_integer(self) -&gt; float:
        &#34;&#34;&#34;Returns the time in seconds to go from compressed to integer, or -1 if it does not exist. In that case
        and if Activation.FORCE_STAT is True, will force the object to call self.as_compress on
        to compute the relevant profiling attributes.&#34;&#34;&#34;
        if self._time_compressed_to_integer == -1 and Activation.FORCE_STAT:
            data = self.data
            fmt = self.data_format
            self.data = self.as_compressed
            if isinstance(self.data, str):
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
            _ = self.as_integer
            self.data = data
            self.data_format = fmt
        return self._time_compressed_to_integer

    @property
    def n_written(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was written to disk.&#34;&#34;&#34;
        return self._n_written

    @property
    def n_read(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was read from disk.&#34;&#34;&#34;
        return self._n_read

    @property
    def n_raw_to_compressed(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was compressed from raw.&#34;&#34;&#34;
        return self._n_raw_to_compressed

    @property
    def n_compressed_to_raw(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to raw.&#34;&#34;&#34;
        return self._n_compressed_to_raw

    @property
    def n_raw_to_bitarray(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was formatted as bitarray.&#34;&#34;&#34;
        return self._n_raw_to_bitarray

    @property
    def n_raw_to_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was formatted as integer.&#34;&#34;&#34;
        return self._n_raw_to_integer

    @property
    def n_bitarray_to_raw(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was deformatted from bitarray.&#34;&#34;&#34;
        return self._n_bitarray_to_raw

    @property
    def n_integer_to_raw(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was deformatted from integer.&#34;&#34;&#34;
        return self._n_integer_to_raw

    @property
    def n_bitarray_to_compressed(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was compressed from bitarray.&#34;&#34;&#34;
        return self._n_bitarray_to_compressed

    @property
    def n_integer_to_compressed(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was compressed from integer.&#34;&#34;&#34;
        return self._n_integer_to_compressed

    @property
    def n_compressed_to_bitarray(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to bitarray.&#34;&#34;&#34;
        return self._n_compressed_to_bitarray

    @property
    def n_compressed_to_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
        return self._n_compressed_to_integer

    @property
    def n_bitarray_to_integer(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
        return self._n_bitarray_to_integer

    @property
    def n_integer_to_bitarray(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
        return self._n_integer_to_bitarray</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.activation.Activation.DEFAULT_TEMPDIR"><code class="name">var <span class="ident">DEFAULT_TEMPDIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.activation.Activation.DTYPE"><code class="name">var <span class="ident">DTYPE</span></code></dt>
<dd>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></div>
</dd>
<dt id="ruleskit.activation.Activation.FORCE_STAT"><code class="name">var <span class="ident">FORCE_STAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.activation.Activation.NCPUS"><code class="name">var <span class="ident">NCPUS</span></code></dt>
<dd>
<div class="desc"><p>Class methods</p></div>
</dd>
<dt id="ruleskit.activation.Activation.STORE_RAW"><code class="name">var <span class="ident">STORE_RAW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.activation.Activation.WILL_COMPARE"><code class="name">var <span class="ident">WILL_COMPARE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ruleskit.activation.Activation.clean_files"><code class="name flex">
<span>def <span class="ident">clean_files</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes activation vector files, if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clean_files(cls):
    &#34;&#34;&#34;Removes activation vector files, if any.&#34;&#34;&#34;
    if not cls.DEFAULT_TEMPDIR.is_dir():
        return
    for path in cls.DEFAULT_TEMPDIR.glob(&#34;ACTIVATION_VECTOR_*.txt&#34;):
        path.unlink()</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.multi_logical_and"><code class="name flex">
<span>def <span class="ident">multi_logical_and</span></span>(<span>acs:List[ForwardRef('<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>')], asarray:bool=False) >Union[<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>,numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Do LOGICAL AND on many activation vectors at once. Uses raw np.ndarrays to gain time.
If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multi_logical_and(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
    &#34;&#34;&#34;Do LOGICAL AND on many activation vectors at once. Uses raw np.ndarrays to gain time.
    If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;

    available_memory = psutil.virtual_memory().available / 1e6
    single_act_size = acs[0].sizeof_raw
    expected_size = single_act_size * len(acs) * Activation.NCPUS * 1.1  # factor 1.1 is just for safety
    if available_memory == 0:
        raise ValueError(&#34;No memory left to compute &#39;multi_logical_and&#39;&#34;)
    nbatches = ceil(expected_size / available_memory)
    if nbatches == 0:
        raise ValueError(
            f&#34;Not enough memory left to compute &#39;multi_logical_and&#39; : need {expected_size}MB,&#34;
            f&#34; has {available_memory}MB&#34;
        )
    batches = np.array_split(acs, nbatches)

    if len(acs) == 1:
        res = acs[0].raw
    else:
        if 2 * single_act_size &gt; available_memory:
            raise MemoryError(&#34;Will not be able to fit two activation vectors of size&#34;
                              f&#34; {acs[0].sizeof_raw} in memory&#34;)
        res = []
        for batch in batches:
            res = np.vstack([a.raw for a in batch]).all(axis=0).astype(np.ubyte)
        res = np.vstack([a for a in res]).all(axis=0).astype(np.ubyte)
    if asarray:
        return res
    return Activation(
        res,
        optimize=all([a.optimize for a in acs]),
        to_file=all([a.data_format == &#34;file&#34; for a in acs]),
    )</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.multi_logical_or"><code class="name flex">
<span>def <span class="ident">multi_logical_or</span></span>(<span>acs:List[ForwardRef('<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>')], asarray:bool=False) >Union[<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>,numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Do LOGICAL OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multi_logical_or(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
    &#34;&#34;&#34;Do LOGICAL OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
    If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;

    available_memory = psutil.virtual_memory().available / 1e6
    single_act_size = acs[0].sizeof_raw
    expected_size = single_act_size * len(acs) * Activation.NCPUS * 1.1  # factor 1.1 is just for safety
    if available_memory == 0:
        raise MemoryError(&#34;No memory left to compute &#39;multi_logical_or&#39;&#34;)
    nbatches = ceil(expected_size / available_memory)
    if nbatches == 0:
        raise MemoryError(
            f&#34;Not enough memory left to compute &#39;multi_logical_or&#39; : need {expected_size}MB,&#34;
            f&#34; has {available_memory}MB&#34;
        )
    batches = np.array_split(acs, nbatches)

    if len(acs) == 1:
        res = acs[0].raw
    else:
        if 2 * single_act_size &gt; available_memory:
            raise MemoryError(&#34;Will not be able to fit two activation vectors of size&#34;
                              f&#34; {acs[0].sizeof_raw} in memory&#34;)
        res = []
        for batch in batches:
            res.append(np.vstack([a.raw for a in batch]).any(axis=0).astype(np.ubyte))
        res = np.vstack([a for a in res]).any(axis=0).astype(np.ubyte)
    if asarray:
        return res
    return Activation(
        res,
        optimize=all([a.optimize for a in acs]),
        to_file=all([a.data_format == &#34;file&#34; for a in acs]),
    )</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.multi_logical_xor"><code class="name flex">
<span>def <span class="ident">multi_logical_xor</span></span>(<span>acs:List[ForwardRef('<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>')], asarray:bool=False) >Union[<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>,numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Do LOGICAL EXCLUSIVE OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multi_logical_xor(acs: List[&#34;Activation&#34;], asarray: bool = False) -&gt; Union[&#34;Activation&#34;, np.ndarray]:
    &#34;&#34;&#34;Do LOGICAL EXCLUSIVE OR on many activation vectors at once. Uses raw np.ndarrays to gain time.
    If asarray is True, does not cast the result into an Activation object but returns the raw np.ndarray.&#34;&#34;&#34;
    if len(acs) == 1:
        return Activation(acs[0].raw, optimize=acs[0].optimize, to_file=acs[0].data_format == &#34;file&#34;)
    lor = Activation.multi_logical_or(acs, True)
    nland = -(Activation.multi_logical_and(acs, True) - 1)
    res = lor &amp; nland.astype(np.ubyte)
    if asarray:
        return res
    return Activation(
        res,
        optimize=all([a.optimize for a in acs]),
        to_file=all([a.data_format == &#34;file&#34; for a in acs]),
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.activation.Activation.as_bitarray"><code class="name">var <span class="ident">as_bitarray</span> :bitarray.bitarray</code></dt>
<dd>
<div class="desc"><p>Returns the bitarray representation of the vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_bitarray(self) -&gt; bitarray:
    &#34;&#34;&#34;Returns the bitarray representation of the vector&#34;&#34;&#34;
    if self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        t0 = time()
        to_ret = self._raw_to_bitarray(data)
        self._time_raw_to_bitarray = time() - t0
        self._n_raw_to_bitarray += 1
        if self._sizeof_bitarray == -1:
            self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
        return to_ret
    elif self.data_format == &#34;raw&#34;:
        t0 = time()
        to_ret = self._raw_to_bitarray(self.data)
        self._time_raw_to_bitarray = time() - t0
        self._n_raw_to_bitarray += 1
        if self._sizeof_bitarray == -1:
            self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
        return to_ret
    elif self.data_format == &#34;bitarray&#34;:
        return self.data
    elif self.data_format == &#34;integer&#34;:
        t0 = time()
        s = bin(self.data)[2:]
        if len(s) != self.length:
            s = &#34;0&#34; * (self.length - len(s)) + s
        to_ret = bitarray(s)
        self._time_integer_to_bitarray = time() - t0
        self._n_integer_to_bitarray += 1
        if self._sizeof_bitarray == -1:
            self._sizeof_bitarray = sys.getsizeof(to_ret) / 1e6
        return to_ret
    elif &#34;compressed&#34; in self.data_format:
        wc = Activation.WILL_COMPARE
        Activation.WILL_COMPARE = False
        to_ret = self._decompress(raw=False, out=False)
        Activation.WILL_COMPARE = wc
        return to_ret
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_compressed"><code class="name">var <span class="ident">as_compressed</span> :str</code></dt>
<dd>
<div class="desc"><p>Returns the compressed str representation of the vector.
Will set relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_compressed(self) -&gt; Union[str]:
    &#34;&#34;&#34;Returns the compressed str representation of the vector.
    Will set relevant profiling attributes.&#34;&#34;&#34;
    return self.as_compressed_str</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_compressed_array"><code class="name">var <span class="ident">as_compressed_array</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the compressed array representation of the vector. Will set relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_compressed_array(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the compressed array representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;
    if self.data_format == &#34;raw&#34;:
        t0 = time()
        to_ret = self._compress(self.data, dtype=np.ndarray)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = to_ret.nbytes / 1e6
    elif self.data_format == &#34;compressed_array&#34;:
        to_ret = self.data
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = to_ret.nbytes / 1e6
    elif self.data_format == &#34;compressed_str&#34;:
        to_ret = np.array(ast.literal_eval(self.data))
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = to_ret.nbytes / 1e6
    elif self.data_format == &#34;integer&#34;:
        t0 = time()
        raw = self.raw
        t1 = time()
        to_ret = self._compress(raw, dtype=np.ndarray)
        self._time_raw_to_compressed = time() - t1
        self._n_raw_to_compressed += 1
        self._time_integer_to_compressed = time() - t0
        self._n_integer_to_compressed += 1
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = to_ret.nbytes / 1e6
    elif self.data_format == &#34;bitarray&#34;:
        t0 = time()
        raw = self.raw
        t1 = time()
        to_ret = self._compress(raw, dtype=np.ndarray)
        self._time_raw_to_compressed = time() - t1
        self._n_raw_to_compressed += 1
        self._time_bitarray_to_compressed = time() - t0
        self._n_bitarray_to_compressed += 1
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = to_ret.nbytes / 1e6
    elif self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        t0 = time()
        to_ret = self._compress(data, dtype=np.ndarray)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)
    self._entropy = len(to_ret)
    if self._rel_entropy is None:
        self._rel_entropy = self._entropy / self.length
    return to_ret</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_compressed_str"><code class="name">var <span class="ident">as_compressed_str</span> :str</code></dt>
<dd>
<div class="desc"><p>Returns the compressed str representation of the vector. Will set relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_compressed_str(self) -&gt; str:
    &#34;&#34;&#34;Returns the compressed str representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;
    if self.data_format == &#34;raw&#34;:
        t0 = time()
        to_ret = self._compress(self.data, dtype=str)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
    elif self.data_format == &#34;compressed_str&#34;:
        to_ret = self.data
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
    elif self.data_format == &#34;compressed_array&#34;:
        to_ret = str(self.data.tolist()).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
    elif self.data_format == &#34;integer&#34;:
        t0 = time()
        raw = self.raw
        t1 = time()
        to_ret = self._compress(raw, dtype=str)
        self._time_raw_to_compressed = time() - t1
        self._n_raw_to_compressed += 1
        self._time_integer_to_compressed = time() - t0
        self._n_integer_to_compressed += 1
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
    elif self.data_format == &#34;bitarray&#34;:
        t0 = time()
        raw = self.raw
        t1 = time()
        to_ret = self._compress(raw, dtype=str)
        self._time_raw_to_compressed = time() - t1
        self._n_raw_to_compressed += 1
        self._time_bitarray_to_compressed = time() - t0
        self._n_bitarray_to_compressed += 1
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret) / 1e6
    elif self.data_format == &#34;file&#34;:
        t0 = time()
        data = self._read(out=False)
        to_ret = self._compress(data, dtype=str)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)
    self._entropy = len(ast.literal_eval(to_ret))
    if self._rel_entropy is None:
        self._rel_entropy = self._entropy / self.length
    return to_ret</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_integer"><code class="name">var <span class="ident">as_integer</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the integer representation of the vector. Will set relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_integer(self) -&gt; int:
    &#34;&#34;&#34;Returns the integer representation of the vector. Will set relevant profiling attributes.&#34;&#34;&#34;

    if self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        t0 = time()
        to_ret = self._raw_to_integer(data)
        self._time_raw_to_integer = time() - t0
        self._n_raw_to_integer += 1
        if self._sizeof_integer == -1:
            self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
        return to_ret
    elif self.data_format == &#34;raw&#34;:
        t0 = time()
        to_ret = self._raw_to_integer(self.data)
        self._time_raw_to_integer = time() - t0
        self._n_raw_to_integer += 1
        if self._sizeof_integer == -1:
            self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
        return to_ret
    elif self.data_format == &#34;integer&#34;:
        return self.data
    elif self.data_format == &#34;bitarray&#34;:
        t0 = time()
        to_ret = int(str(self.data).replace(&#34;bitarray(&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#39;&#34;&#39;, &#34;&#34;), 2)
        self._time_bitarray_to_integer = time() - t0
        self._n_bitarray_to_integer += 1
        self._sizeof_integer = sys.getsizeof(to_ret) / 1e6
        return to_ret
    elif &#34;compressed&#34; in self.data_format:
        wc = Activation.WILL_COMPARE
        Activation.WILL_COMPARE = True
        to_ret = self._decompress(raw=False, out=False)
        Activation.WILL_COMPARE = wc
        return to_ret
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.coverage"><code class="name">var <span class="ident">coverage</span> :float</code></dt>
<dd>
<div class="desc"><p>Coverage is the fraction of points equal to 1 in the vector
Like self._nones, it might not have been computed yet. In that case, compute it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coverage(self) -&gt; float:
    &#34;&#34;&#34;Coverage is the fraction of points equal to 1 in the vector
    Like self._nones, it might not have been computed yet. In that case, compute it.
    &#34;&#34;&#34;
    if self._coverage is None:
        _ = self.nones  # will set self._coverage
    return self._coverage</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.entropy"><code class="name">var <span class="ident">entropy</span> :int</code></dt>
<dd>
<div class="desc"><p>The entropy of the vector is the length of its compressed reprensentation : the number of times it switched
from 1 to 0 and vice versa, plus 1 for the information about its initial value, and again 1 for the Information
about its size.
Like self._nones, it might not have been computed yet. In that case, compute it.</p>
<p>If entropy is ocmputed here, will set:
* self._time_bitarray_to_compressed or self._time_integer_to_compressed
* self._sizeof_compressed_str or self._sizeof_compressed_array
* self._entropy (you don't say)
* self._rel_entropy
Will iterate :
* self._n_bitarray_to_compressed or self._n_integer_to_compressed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def entropy(self) -&gt; int:
    &#34;&#34;&#34;The entropy of the vector is the length of its compressed reprensentation : the number of times it switched
    from 1 to 0 and vice versa, plus 1 for the information about its initial value, and again 1 for the Information
    about its size.
    Like self._nones, it might not have been computed yet. In that case, compute it.

    If entropy is ocmputed here, will set:
        * self._time_bitarray_to_compressed or self._time_integer_to_compressed
        * self._sizeof_compressed_str or self._sizeof_compressed_array
        * self._entropy (you don&#39;t say)
        * self._rel_entropy
        Will iterate :
            * self._n_bitarray_to_compressed or self._n_integer_to_compressed
    &#34;&#34;&#34;
    if self._entropy is None:
        t0 = time()
        fmt = self.data_format
        if self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            fmt = &#34;raw&#34;
        else:
            data = self.data

        if fmt == &#34;bitarray&#34;:
            data = self._bitarray_to_raw(data, out=False)
            compressed = self._compress(data)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
        elif fmt == &#34;integer&#34;:
            data = self._integer_to_raw(data, out=False)
            compressed = self._compress(data)
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
        elif fmt == &#34;raw&#34;:
            compressed = self._compress(data)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        else:
            raise ValueError(f&#34;Entropy should have been computed already if format is {fmt}&#34;)

        if self.data_format == &#34;compressed_str&#34;:
            self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
        if self.data_format == &#34;compressed_array&#34;:
            self._sizeof_compressed_array = compressed.nbytes / 1e6

        self._entropy = len(ast.literal_eval(compressed))
    if self._rel_entropy is None:
        self._rel_entropy = self._entropy / self.length
    return self._entropy</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_bitarray_to_compressed"><code class="name">var <span class="ident">n_bitarray_to_compressed</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was compressed from bitarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_bitarray_to_compressed(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was compressed from bitarray.&#34;&#34;&#34;
    return self._n_bitarray_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_bitarray_to_integer"><code class="name">var <span class="ident">n_bitarray_to_integer</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was decompressed to integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_bitarray_to_integer(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
    return self._n_bitarray_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_bitarray_to_raw"><code class="name">var <span class="ident">n_bitarray_to_raw</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was deformatted from bitarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_bitarray_to_raw(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was deformatted from bitarray.&#34;&#34;&#34;
    return self._n_bitarray_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_compressed_to_bitarray"><code class="name">var <span class="ident">n_compressed_to_bitarray</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was decompressed to bitarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_compressed_to_bitarray(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was decompressed to bitarray.&#34;&#34;&#34;
    return self._n_compressed_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_compressed_to_integer"><code class="name">var <span class="ident">n_compressed_to_integer</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was decompressed to integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_compressed_to_integer(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
    return self._n_compressed_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_compressed_to_raw"><code class="name">var <span class="ident">n_compressed_to_raw</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was decompressed to raw.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_compressed_to_raw(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was decompressed to raw.&#34;&#34;&#34;
    return self._n_compressed_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_integer_to_bitarray"><code class="name">var <span class="ident">n_integer_to_bitarray</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was decompressed to integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_integer_to_bitarray(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was decompressed to integer.&#34;&#34;&#34;
    return self._n_integer_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_integer_to_compressed"><code class="name">var <span class="ident">n_integer_to_compressed</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was compressed from integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_integer_to_compressed(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was compressed from integer.&#34;&#34;&#34;
    return self._n_integer_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_integer_to_raw"><code class="name">var <span class="ident">n_integer_to_raw</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was deformatted from integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_integer_to_raw(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was deformatted from integer.&#34;&#34;&#34;
    return self._n_integer_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_raw_to_bitarray"><code class="name">var <span class="ident">n_raw_to_bitarray</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was formatted as bitarray.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_raw_to_bitarray(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was formatted as bitarray.&#34;&#34;&#34;
    return self._n_raw_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_raw_to_compressed"><code class="name">var <span class="ident">n_raw_to_compressed</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was compressed from raw.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_raw_to_compressed(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was compressed from raw.&#34;&#34;&#34;
    return self._n_raw_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_raw_to_integer"><code class="name">var <span class="ident">n_raw_to_integer</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was formatted as integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_raw_to_integer(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was formatted as integer.&#34;&#34;&#34;
    return self._n_raw_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_read"><code class="name">var <span class="ident">n_read</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was read from disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_read(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was read from disk.&#34;&#34;&#34;
    return self._n_read</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_written"><code class="name">var <span class="ident">n_written</span> :int</code></dt>
<dd>
<div class="desc"><p>Returns the number of time the vector was written to disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_written(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of time the vector was written to disk.&#34;&#34;&#34;
    return self._n_written</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.nones"><code class="name">var <span class="ident">nones</span> :int</code></dt>
<dd>
<div class="desc"><p>nones is the number of points where the activation vector is 1
self._nones might not be set since it can only be set at object creation if the full array was given or
accessed at some point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nones(self) -&gt; int:
    &#34;&#34;&#34;nones is the number of points where the activation vector is 1
    self._nones might not be set since it can only be set at object creation if the full array was given or
    accessed at some point
    &#34;&#34;&#34;
    if self._nones is None:
        _ = self.raw  # calling raw will compute nones

    if self._coverage is None:
        self._coverage = self._nones / self.length
    return self._nones</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.ones"><code class="name">var <span class="ident">ones</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>ones is the list of indexes where the vector is 1
Contrary to other @properties, do not store 'ones' in self, for it can be quit large : several MB or more.
When running codes with millions of vector, this can be problematic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ones(self) -&gt; np.ndarray:
    &#34;&#34;&#34;ones is the list of indexes where the vector is 1
    Contrary to other @properties, do not store &#39;ones&#39; in self, for it can be quit large : several MB or more.
    When running codes with millions of vector, this can be problematic.&#34;&#34;&#34;
    raw = self.raw
    ones = np.where(raw == 1)[0].tolist()
    return ones</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.raw"><code class="name">var <span class="ident">raw</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the raw np.ndarray. Will set relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the raw np.ndarray. Will set relevant profiling attributes.&#34;&#34;&#34;
    if self.data_format == &#34;raw&#34;:
        return self.data
    elif self.data_format == &#34;bitarray&#34;:
        return self._bitarray_to_raw(out=False)
    elif self.data_format == &#34;integer&#34;:
        return self._integer_to_raw(out=False)
    elif self.data_format == &#34;file&#34;:
        return self._read(out=False)
    elif &#34;compressed&#34; in self.data_format:
        return self._decompress(out=False)
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.rel_entropy"><code class="name">var <span class="ident">rel_entropy</span> :float</code></dt>
<dd>
<div class="desc"><p>Relative entropy is the entropy divided by the length of the raw np.ndarray vector
Like self._nones, it might not have been computed yet. In that case, compute it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rel_entropy(self) -&gt; float:
    &#34;&#34;&#34;Relative entropy is the entropy divided by the length of the raw np.ndarray vector
    Like self._nones, it might not have been computed yet. In that case, compute it.
    &#34;&#34;&#34;
    if self._rel_entropy is None:
        _ = self.entropy  # will set self._rel_entropy
    return self._rel_entropy</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_bitarray"><code class="name">var <span class="ident">sizeof_bitarray</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of the vector in bitarray, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self.as_bitarray to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_bitarray(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of the vector in bitarray, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self.as_bitarray to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._sizeof_bitarray == -1 and Activation.FORCE_STAT:
        _ = self.as_bitarray
    return self._sizeof_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_compressed_array"><code class="name">var <span class="ident">sizeof_compressed_array</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of the vector in compressed array, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self.as_compressed_array to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_compressed_array(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of the vector in compressed array, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self.as_compressed_array to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._sizeof_compressed_array == -1 and Activation.FORCE_STAT:
        _ = self.as_compressed_array
    return self._sizeof_compressed_array</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_compressed_str"><code class="name">var <span class="ident">sizeof_compressed_str</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of the vector in compressed str, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self.as_compressed_str to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_compressed_str(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of the vector in compressed str, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self.as_compressed_str to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._sizeof_compressed_str == -1 and Activation.FORCE_STAT:
        _ = self.as_compressed_str
    return self._sizeof_compressed_str</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_file"><code class="name">var <span class="ident">sizeof_file</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of the path object, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_file(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of the path object, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
    attributes.&#34;&#34;&#34;
    if self._sizeof_file == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self._write(self.raw)
        self.data.unlink()
        self.data = data
        self.data_format = fmt
    return self._sizeof_file</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_integer"><code class="name">var <span class="ident">sizeof_integer</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of the vector in integer, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self.as_integer to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_integer(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of the vector in integer, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self.as_integer to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._sizeof_integer == -1 and Activation.FORCE_STAT:
        _ = self.as_integer
    return self._sizeof_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_path"><code class="name">var <span class="ident">sizeof_path</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of the path object, or -1 if it does not exist.
In that case and if Activation.FORCE_STAT is True, will force the object to write the file to compute the
relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_path(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of the path object, or -1 if it does not exist.
    In that case and if Activation.FORCE_STAT is True, will force the object to write the file to compute the
     relevant profiling attributes.&#34;&#34;&#34;
    if self._sizeof_path == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self._write(self.raw)
        self.data.unlink()
        self.data = data
        self.data_format = fmt
    return self._sizeof_path</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_raw"><code class="name">var <span class="ident">sizeof_raw</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the size in MB of raw np.ndarray vector, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self.raw to compute the relevant profiling
attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_raw(self) -&gt; float:
    &#34;&#34;&#34;Returns the size in MB of raw np.ndarray vector, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self.raw to compute the relevant profiling
    attributes.&#34;&#34;&#34;
    if self._sizeof_raw == -1 and Activation.FORCE_STAT:
        _ = self.raw
    return self._sizeof_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_bitarray_to_compressed"><code class="name">var <span class="ident">time_bitarray_to_compressed</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from bitarray to compressed, or -1 if it does not exist. In that case
and if Activation.FORCE_STAT is True, will force the object to call self._compress on self.as_bitarray to
compute the relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bitarray_to_compressed(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from bitarray to compressed, or -1 if it does not exist. In that case
    and if Activation.FORCE_STAT is True, will force the object to call self._compress on self.as_bitarray to
    compute the relevant profiling attributes.&#34;&#34;&#34;
    if self._time_bitarray_to_compressed == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_bitarray
        self.data_format = &#34;bitarray&#34;
        _ = self.as_compressed
        self.data = data
        self.data_format = fmt
    return self._time_bitarray_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_bitarray_to_integer"><code class="name">var <span class="ident">time_bitarray_to_integer</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
and if Activation.FORCE_STAT is True, will force the object to call self._compress on
self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bitarray_to_integer(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
    and if Activation.FORCE_STAT is True, will force the object to call self._compress on
    self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.&#34;&#34;&#34;
    if self._time_bitarray_to_integer == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_bitarray
        self.data_format = &#34;bitarray&#34;
        _ = self.as_integer
        self.data = data
        self.data_format = fmt
    return self._time_bitarray_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_bitarray_to_raw"><code class="name">var <span class="ident">time_bitarray_to_raw</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from bitarray to raw, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self._bitarray_to_raw to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bitarray_to_raw(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from bitarray to raw, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self._bitarray_to_raw to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._time_bitarray_to_raw == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_bitarray
        self.data_format = &#34;bitarray&#34;
        _ = self.raw
        self.data = data
        self.data_format = fmt
    return self._time_bitarray_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_compressed_to_bitarray"><code class="name">var <span class="ident">time_compressed_to_bitarray</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from compressed to bitarray, or -1 if it does not exist. In that case
and if Activation.FORCE_STAT is True, will force the object to call self._decompress on self.as_compressed with
'raw=False' to compute the relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_compressed_to_bitarray(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from compressed to bitarray, or -1 if it does not exist. In that case
    and if Activation.FORCE_STAT is True, will force the object to call self._decompress on self.as_compressed with
     &#39;raw=False&#39; to compute the relevant profiling attributes.&#34;&#34;&#34;
    if self._time_compressed_to_bitarray == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_compressed
        if isinstance(self.data, str):
            self.data_format = &#34;compressed_str&#34;
        else:
            self.data_format = &#34;compressed_array&#34;
        _ = self.as_bitarray
        self.data = data
        self.data_format = fmt
    return self._time_compressed_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_compressed_to_integer"><code class="name">var <span class="ident">time_compressed_to_integer</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from compressed to integer, or -1 if it does not exist. In that case
and if Activation.FORCE_STAT is True, will force the object to call self.as_compress on
to compute the relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_compressed_to_integer(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from compressed to integer, or -1 if it does not exist. In that case
    and if Activation.FORCE_STAT is True, will force the object to call self.as_compress on
    to compute the relevant profiling attributes.&#34;&#34;&#34;
    if self._time_compressed_to_integer == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_compressed
        if isinstance(self.data, str):
            self.data_format = &#34;compressed_str&#34;
        else:
            self.data_format = &#34;compressed_array&#34;
        _ = self.as_integer
        self.data = data
        self.data_format = fmt
    return self._time_compressed_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_compressed_to_raw"><code class="name">var <span class="ident">time_compressed_to_raw</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self._decompress to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_compressed_to_raw(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self._decompress to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._time_compressed_to_raw == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_compressed
        if isinstance(self.data, str):
            self.data_format = &#34;compressed_str&#34;
        else:
            self.data_format = &#34;compressed_array&#34;
        _ = self.raw
        self.data = data
        self.data_format = fmt
    return self._time_compressed_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_integer_to_bitarray"><code class="name">var <span class="ident">time_integer_to_bitarray</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
and if Activation.FORCE_STAT is True, will force the object to call self.as_integer on
self to compute the relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_integer_to_bitarray(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from bitarray to integer, or -1 if it does not exist. In that case
    and if Activation.FORCE_STAT is True, will force the object to call self.as_integer on
    self to compute the relevant profiling attributes.&#34;&#34;&#34;
    if self._time_integer_to_bitarray == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_integer
        self.data_format = &#34;integer&#34;
        _ = self.as_bitarray
        self.data = data
        self.data_format = fmt
    return self._time_integer_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_integer_to_compressed"><code class="name">var <span class="ident">time_integer_to_compressed</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from integer to compressed, or -1 if it does not exist. In that case
and if Activation.FORCE_STAT is True, will force the object to call self._compress on
self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_integer_to_compressed(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from integer to compressed, or -1 if it does not exist. In that case
    and if Activation.FORCE_STAT is True, will force the object to call self._compress on
    self._integer_to_raw(self.as_integer) to compute the relevant profiling attributes.&#34;&#34;&#34;
    if self._time_integer_to_compressed == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_integer
        self.data_format = &#34;integer&#34;
        _ = self.as_compressed
        self.data = data
        self.data_format = fmt
    return self._time_integer_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_integer_to_raw"><code class="name">var <span class="ident">time_integer_to_raw</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to go from integer to raw, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self._integer_to_raw to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_integer_to_raw(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to go from integer to raw, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self._integer_to_raw to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._time_integer_to_raw == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.as_integer
        self.data_format = &#34;integer&#34;
        _ = self.raw
        self.data = data
        self.data_format = fmt
    return self._time_integer_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_raw_to_bitarray"><code class="name">var <span class="ident">time_raw_to_bitarray</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds go from raw to bitarray, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self._raw_to_bitarray to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_raw_to_bitarray(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds go from raw to bitarray, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self._raw_to_bitarray to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._time_raw_to_bitarray == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.raw
        self.data_format = &#34;raw&#34;
        _ = self.as_bitarray
        self.data = data
        self.data_format = fmt
    return self._time_raw_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_raw_to_compressed"><code class="name">var <span class="ident">time_raw_to_compressed</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self._compress to compute the relevant profiling
attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_raw_to_compressed(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to compress the vector, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self._compress to compute the relevant profiling
    attributes.&#34;&#34;&#34;
    if self._time_raw_to_compressed == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.raw
        self.data_format = &#34;raw&#34;
        _ = self.as_compressed
        self.data = data
        self.data_format = fmt
    return self._time_raw_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_raw_to_integer"><code class="name">var <span class="ident">time_raw_to_integer</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds go from raw to integer, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to call self._raw_to_integer to compute the relevant
profiling attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_raw_to_integer(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds go from raw to integer, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to call self._raw_to_integer to compute the relevant
    profiling attributes.&#34;&#34;&#34;
    if self._time_raw_to_integer == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self.data = self.raw
        self.data_format = &#34;raw&#34;
        _ = self.as_integer
        self.data = data
        self.data_format = fmt
    return self._time_raw_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_read"><code class="name">var <span class="ident">time_read</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to read the vector to a file, or -1 if it does not exist. In that case and if
Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_read(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to read the vector to a file, or -1 if it does not exist. In that case and if
    Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
    attributes.&#34;&#34;&#34;
    if self._time_read == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self._write(self.raw)
        _ = self._read(self.data, out=False)
        self.data.unlink()
        self.data = data
        self.data_format = fmt
    return self._time_read</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_write"><code class="name">var <span class="ident">time_write</span> :float</code></dt>
<dd>
<div class="desc"><p>Returns the time in seconds to write the vector to a file, or -1 if it does not exist. In that case and
if Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_write(self) -&gt; float:
    &#34;&#34;&#34;Returns the time in seconds to write the vector to a file, or -1 if it does not exist. In that case and
    if Activation.FORCE_STAT is True, will force the object to write the file to compute the relevant profiling
    attributes.&#34;&#34;&#34;
    if self._time_write == -1 and Activation.FORCE_STAT:
        data = self.data
        fmt = self.data_format
        self._write(self.raw)
        self.data.unlink()
        self.data = data
        self.data_format = fmt
    return self._time_write</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.activation.Activation.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill Activation with zeros</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Fill Activation with zeros&#34;&#34;&#34;
    data = np.zeros(self.length)
    self._reset_data_related_attributes()
    self._init_with_raw(data, Activation.DTYPE)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the activation vector's data, either by deleting the local file or by calling del on self.data. In
the later case, self.data is reset to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;Deletes the activation vector&#39;s data, either by deleting the local file or by calling del on self.data. In
    the later case, self.data is reset to None.&#34;&#34;&#34;
    if self.data_format == &#34;file&#34;:
        if self.data.is_file():
            self.data.unlink()
    else:
        del self.data
        self.data = None</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.get_correlation"><code class="name flex">
<span>def <span class="ident">get_correlation</span></span>(<span>self, other:<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the correlation between self and other
Correlation is the number of points in common between the two vectors divided by their length.
Both vectors must have the same length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_correlation(self, other: &#34;Activation&#34;) -&gt; float:
    &#34;&#34;&#34; Computes the correlation between self and other
    Correlation is the number of points in common between the two vectors divided by their length.
    Both vectors must have the same length.
    &#34;&#34;&#34;
    if not len(self) == len(other):
        raise ValueError(&#34;Both vectors must have the same length&#34;)

    common_points = np.count_nonzero(self.raw == other.raw)
    return common_points / len(self)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.to_raw_from_any"><code class="name flex">
<span>def <span class="ident">to_raw_from_any</span></span>(<span>self, activation, out:bool=True) >numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts any format among integer, bitarray, compressed string or compressed array to raw activation
vector np.ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_raw_from_any(self, activation, out: bool = True) -&gt; np.ndarray:
    &#34;&#34;&#34;Converts any format among integer, bitarray, compressed string or compressed array to raw activation
    vector np.ndarray&#34;&#34;&#34;
    if isinstance(activation, bitarray):
        raw = self._bitarray_to_raw(activation, out=out)
    elif isinstance(activation, int):
        raw = self._integer_to_raw(activation, out=out)
    elif isinstance(activation, (str, np.ndarray)):
        raw = self._decompress(activation, raw=True, out=out)
    else:
        raise TypeError(
            f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
            f&#34; {type(activation)}.&#34;
        )
    return raw</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ruleskit" href="index.html">ruleskit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.activation.Activation.DEFAULT_TEMPDIR" href="#ruleskit.activation.Activation.DEFAULT_TEMPDIR">DEFAULT_TEMPDIR</a></code></li>
<li><code><a title="ruleskit.activation.Activation.DTYPE" href="#ruleskit.activation.Activation.DTYPE">DTYPE</a></code></li>
<li><code><a title="ruleskit.activation.Activation.FORCE_STAT" href="#ruleskit.activation.Activation.FORCE_STAT">FORCE_STAT</a></code></li>
<li><code><a title="ruleskit.activation.Activation.NCPUS" href="#ruleskit.activation.Activation.NCPUS">NCPUS</a></code></li>
<li><code><a title="ruleskit.activation.Activation.STORE_RAW" href="#ruleskit.activation.Activation.STORE_RAW">STORE_RAW</a></code></li>
<li><code><a title="ruleskit.activation.Activation.WILL_COMPARE" href="#ruleskit.activation.Activation.WILL_COMPARE">WILL_COMPARE</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_bitarray" href="#ruleskit.activation.Activation.as_bitarray">as_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_compressed" href="#ruleskit.activation.Activation.as_compressed">as_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_compressed_array" href="#ruleskit.activation.Activation.as_compressed_array">as_compressed_array</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_compressed_str" href="#ruleskit.activation.Activation.as_compressed_str">as_compressed_str</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_integer" href="#ruleskit.activation.Activation.as_integer">as_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.clean_files" href="#ruleskit.activation.Activation.clean_files">clean_files</a></code></li>
<li><code><a title="ruleskit.activation.Activation.clear" href="#ruleskit.activation.Activation.clear">clear</a></code></li>
<li><code><a title="ruleskit.activation.Activation.coverage" href="#ruleskit.activation.Activation.coverage">coverage</a></code></li>
<li><code><a title="ruleskit.activation.Activation.delete" href="#ruleskit.activation.Activation.delete">delete</a></code></li>
<li><code><a title="ruleskit.activation.Activation.entropy" href="#ruleskit.activation.Activation.entropy">entropy</a></code></li>
<li><code><a title="ruleskit.activation.Activation.get_correlation" href="#ruleskit.activation.Activation.get_correlation">get_correlation</a></code></li>
<li><code><a title="ruleskit.activation.Activation.multi_logical_and" href="#ruleskit.activation.Activation.multi_logical_and">multi_logical_and</a></code></li>
<li><code><a title="ruleskit.activation.Activation.multi_logical_or" href="#ruleskit.activation.Activation.multi_logical_or">multi_logical_or</a></code></li>
<li><code><a title="ruleskit.activation.Activation.multi_logical_xor" href="#ruleskit.activation.Activation.multi_logical_xor">multi_logical_xor</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_bitarray_to_compressed" href="#ruleskit.activation.Activation.n_bitarray_to_compressed">n_bitarray_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_bitarray_to_integer" href="#ruleskit.activation.Activation.n_bitarray_to_integer">n_bitarray_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_bitarray_to_raw" href="#ruleskit.activation.Activation.n_bitarray_to_raw">n_bitarray_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_compressed_to_bitarray" href="#ruleskit.activation.Activation.n_compressed_to_bitarray">n_compressed_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_compressed_to_integer" href="#ruleskit.activation.Activation.n_compressed_to_integer">n_compressed_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_compressed_to_raw" href="#ruleskit.activation.Activation.n_compressed_to_raw">n_compressed_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_integer_to_bitarray" href="#ruleskit.activation.Activation.n_integer_to_bitarray">n_integer_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_integer_to_compressed" href="#ruleskit.activation.Activation.n_integer_to_compressed">n_integer_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_integer_to_raw" href="#ruleskit.activation.Activation.n_integer_to_raw">n_integer_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_raw_to_bitarray" href="#ruleskit.activation.Activation.n_raw_to_bitarray">n_raw_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_raw_to_compressed" href="#ruleskit.activation.Activation.n_raw_to_compressed">n_raw_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_raw_to_integer" href="#ruleskit.activation.Activation.n_raw_to_integer">n_raw_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_read" href="#ruleskit.activation.Activation.n_read">n_read</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_written" href="#ruleskit.activation.Activation.n_written">n_written</a></code></li>
<li><code><a title="ruleskit.activation.Activation.nones" href="#ruleskit.activation.Activation.nones">nones</a></code></li>
<li><code><a title="ruleskit.activation.Activation.ones" href="#ruleskit.activation.Activation.ones">ones</a></code></li>
<li><code><a title="ruleskit.activation.Activation.raw" href="#ruleskit.activation.Activation.raw">raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.rel_entropy" href="#ruleskit.activation.Activation.rel_entropy">rel_entropy</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_bitarray" href="#ruleskit.activation.Activation.sizeof_bitarray">sizeof_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_compressed_array" href="#ruleskit.activation.Activation.sizeof_compressed_array">sizeof_compressed_array</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_compressed_str" href="#ruleskit.activation.Activation.sizeof_compressed_str">sizeof_compressed_str</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_file" href="#ruleskit.activation.Activation.sizeof_file">sizeof_file</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_integer" href="#ruleskit.activation.Activation.sizeof_integer">sizeof_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_path" href="#ruleskit.activation.Activation.sizeof_path">sizeof_path</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_raw" href="#ruleskit.activation.Activation.sizeof_raw">sizeof_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_bitarray_to_compressed" href="#ruleskit.activation.Activation.time_bitarray_to_compressed">time_bitarray_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_bitarray_to_integer" href="#ruleskit.activation.Activation.time_bitarray_to_integer">time_bitarray_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_bitarray_to_raw" href="#ruleskit.activation.Activation.time_bitarray_to_raw">time_bitarray_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_compressed_to_bitarray" href="#ruleskit.activation.Activation.time_compressed_to_bitarray">time_compressed_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_compressed_to_integer" href="#ruleskit.activation.Activation.time_compressed_to_integer">time_compressed_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_compressed_to_raw" href="#ruleskit.activation.Activation.time_compressed_to_raw">time_compressed_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_integer_to_bitarray" href="#ruleskit.activation.Activation.time_integer_to_bitarray">time_integer_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_integer_to_compressed" href="#ruleskit.activation.Activation.time_integer_to_compressed">time_integer_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_integer_to_raw" href="#ruleskit.activation.Activation.time_integer_to_raw">time_integer_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_raw_to_bitarray" href="#ruleskit.activation.Activation.time_raw_to_bitarray">time_raw_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_raw_to_compressed" href="#ruleskit.activation.Activation.time_raw_to_compressed">time_raw_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_raw_to_integer" href="#ruleskit.activation.Activation.time_raw_to_integer">time_raw_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_read" href="#ruleskit.activation.Activation.time_read">time_read</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_write" href="#ruleskit.activation.Activation.time_write">time_write</a></code></li>
<li><code><a title="ruleskit.activation.Activation.to_raw_from_any" href="#ruleskit.activation.Activation.to_raw_from_any">to_raw_from_any</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>